// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             (unknown)
// source: api/v0alpha/callqueue.proto

package v0alpha

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	CallQueue_DequeuePreviewRecordOrCall_FullMethodName          = "/api.v0alpha.CallQueue/DequeuePreviewRecordOrCall"
	CallQueue_EnqueuePreviewRecord_FullMethodName                = "/api.v0alpha.CallQueue/EnqueuePreviewRecord"
	CallQueue_DequeueScrubbedCallForPreviewRecord_FullMethodName = "/api.v0alpha.CallQueue/DequeueScrubbedCallForPreviewRecord"
	CallQueue_ClearPreviewRecordReturnQueue_FullMethodName       = "/api.v0alpha.CallQueue/ClearPreviewRecordReturnQueue"
	CallQueue_EnqueuePreviewDialCall_FullMethodName              = "/api.v0alpha.CallQueue/EnqueuePreviewDialCall"
	CallQueue_ClearManualDialQueue_FullMethodName                = "/api.v0alpha.CallQueue/ClearManualDialQueue"
	CallQueue_ProcessManualDialCall_FullMethodName               = "/api.v0alpha.CallQueue/ProcessManualDialCall"
	CallQueue_DequeueCallForManualApproval_FullMethodName        = "/api.v0alpha.CallQueue/DequeueCallForManualApproval"
	CallQueue_EnqueueManuallyApprovedCall_FullMethodName         = "/api.v0alpha.CallQueue/EnqueueManuallyApprovedCall"
	CallQueue_EnqueueManuallyRejectedCall_FullMethodName         = "/api.v0alpha.CallQueue/EnqueueManuallyRejectedCall"
	CallQueue_RequeueManuallyApprovedCall_FullMethodName         = "/api.v0alpha.CallQueue/RequeueManuallyApprovedCall"
	CallQueue_EnqueueManuallyApprovedSms_FullMethodName          = "/api.v0alpha.CallQueue/EnqueueManuallyApprovedSms"
	CallQueue_EnqueueManuallyRejectedSms_FullMethodName          = "/api.v0alpha.CallQueue/EnqueueManuallyRejectedSms"
	CallQueue_RequeueManuallyApprovedSms_FullMethodName          = "/api.v0alpha.CallQueue/RequeueManuallyApprovedSms"
	CallQueue_DequeueSmsMamForManualApproval_FullMethodName      = "/api.v0alpha.CallQueue/DequeueSmsMamForManualApproval"
)

// CallQueueClient is the client API for CallQueue service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CallQueueClient interface {
	// Returns either a preview record or preview call from one of multiple queues,
	// it also returns a field for the queue name so record/call can be enqueued back to the same queue.
	// It checks for a record first, if no record is dequeued, then the preview call queues will be checked.
	DequeuePreviewRecordOrCall(ctx context.Context, in *DequeuePreviewRecordOrCallReq, opts ...grpc.CallOption) (*DequeuePreviewRecordOrCallRes, error)
	// Enqueues the given preview record into the specified queue.
	EnqueuePreviewRecord(ctx context.Context, in *EnqueuePreviewRecordReq, opts ...grpc.CallOption) (*EnqueuePreviewRecordRes, error)
	// Returns the scrubbed simple call data for the given preview record.
	DequeueScrubbedCallForPreviewRecord(ctx context.Context, in *DequeueScrubbedCallForPreviewRecordReq, opts ...grpc.CallOption) (*DequeueScrubbedCallForPreviewRecordRes, error)
	// Clears the preview record return queue for the requesting agent.
	ClearPreviewRecordReturnQueue(ctx context.Context, in *ClearPreviewRecordReturnQueueReq, opts ...grpc.CallOption) (*ClearPreviewRecordReturnQueueRes, error)
	// Enqueues the given preview dial call into the specified queue.
	EnqueuePreviewDialCall(ctx context.Context, in *EnqueuePreviewDialCallReq, opts ...grpc.CallOption) (*EnqueuePreviewDialCallRes, error)
	// Clears the manual dial return queue of the requesting agent.
	ClearManualDialQueue(ctx context.Context, in *ClearManualDialQueueReq, opts ...grpc.CallOption) (*ClearManualDialQueueRes, error)
	// Enqueues the call to the manual dial receive queue for scrubbing.
	// The call will then be added to the manual dial return queue of the requesting agent.
	// The scrubbed call is then dequeued from that agent's manual dial return queue and returned.
	ProcessManualDialCall(ctx context.Context, in *ProcessManualDialCallReq, opts ...grpc.CallOption) (*ProcessManualDialCallRes, error)
	// Dequeues a call for manual approval from the requesting agent's hunt group queues or a client queue,
	// it also returns a field for the queue name so call can be enqueued back to the same queue.
	DequeueCallForManualApproval(ctx context.Context, in *DequeueCallForManualApprovalReq, opts ...grpc.CallOption) (*DequeueCallForManualApprovalRes, error)
	// Enqueues a call in the MAC approval queue.
	EnqueueManuallyApprovedCall(ctx context.Context, in *EnqueueManuallyApprovedCallReq, opts ...grpc.CallOption) (*EnqueueManuallyApprovedCallRes, error)
	// Enqueues a call in the MAC rejection queue.
	EnqueueManuallyRejectedCall(ctx context.Context, in *EnqueueManuallyRejectedCallReq, opts ...grpc.CallOption) (*EnqueueManuallyRejectedCallRes, error)
	// Requeues a call requiring manual approval to the specified queue.
	RequeueManuallyApprovedCall(ctx context.Context, in *RequeueManuallyApprovedCallReq, opts ...grpc.CallOption) (*RequeueManuallyApprovedCallRes, error)
	// Enqueues sms msg in the MAM approval queue.
	EnqueueManuallyApprovedSms(ctx context.Context, in *EnqueueManuallyApprovedSmsReq, opts ...grpc.CallOption) (*EnqueueManuallyApprovedSmsRes, error)
	// Enqueues sms msg in the MAM rejection queue.
	EnqueueManuallyRejectedSms(ctx context.Context, in *EnqueueManuallyRejectedSmsReq, opts ...grpc.CallOption) (*EnqueueManuallyRejectedSmsRes, error)
	// Requeues sms msg requiring manual approval to the specified queue.
	RequeueManuallyApprovedSms(ctx context.Context, in *RequeueManuallyApprovedSmsReq, opts ...grpc.CallOption) (*RequeueManuallyApprovedSmsRes, error)
	// Dequeues a sms mam msg for manual approval from the requesting agent's hunt group queues or a client queue,
	// it also returns a field for the queue name so sms mam msg can be enqueued back to the same queue.
	DequeueSmsMamForManualApproval(ctx context.Context, in *DequeueSmsMamForManualApprovalReq, opts ...grpc.CallOption) (*DequeueSmsMamForManualApprovalRes, error)
}

type callQueueClient struct {
	cc grpc.ClientConnInterface
}

func NewCallQueueClient(cc grpc.ClientConnInterface) CallQueueClient {
	return &callQueueClient{cc}
}

func (c *callQueueClient) DequeuePreviewRecordOrCall(ctx context.Context, in *DequeuePreviewRecordOrCallReq, opts ...grpc.CallOption) (*DequeuePreviewRecordOrCallRes, error) {
	out := new(DequeuePreviewRecordOrCallRes)
	err := c.cc.Invoke(ctx, CallQueue_DequeuePreviewRecordOrCall_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *callQueueClient) EnqueuePreviewRecord(ctx context.Context, in *EnqueuePreviewRecordReq, opts ...grpc.CallOption) (*EnqueuePreviewRecordRes, error) {
	out := new(EnqueuePreviewRecordRes)
	err := c.cc.Invoke(ctx, CallQueue_EnqueuePreviewRecord_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *callQueueClient) DequeueScrubbedCallForPreviewRecord(ctx context.Context, in *DequeueScrubbedCallForPreviewRecordReq, opts ...grpc.CallOption) (*DequeueScrubbedCallForPreviewRecordRes, error) {
	out := new(DequeueScrubbedCallForPreviewRecordRes)
	err := c.cc.Invoke(ctx, CallQueue_DequeueScrubbedCallForPreviewRecord_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *callQueueClient) ClearPreviewRecordReturnQueue(ctx context.Context, in *ClearPreviewRecordReturnQueueReq, opts ...grpc.CallOption) (*ClearPreviewRecordReturnQueueRes, error) {
	out := new(ClearPreviewRecordReturnQueueRes)
	err := c.cc.Invoke(ctx, CallQueue_ClearPreviewRecordReturnQueue_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *callQueueClient) EnqueuePreviewDialCall(ctx context.Context, in *EnqueuePreviewDialCallReq, opts ...grpc.CallOption) (*EnqueuePreviewDialCallRes, error) {
	out := new(EnqueuePreviewDialCallRes)
	err := c.cc.Invoke(ctx, CallQueue_EnqueuePreviewDialCall_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *callQueueClient) ClearManualDialQueue(ctx context.Context, in *ClearManualDialQueueReq, opts ...grpc.CallOption) (*ClearManualDialQueueRes, error) {
	out := new(ClearManualDialQueueRes)
	err := c.cc.Invoke(ctx, CallQueue_ClearManualDialQueue_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *callQueueClient) ProcessManualDialCall(ctx context.Context, in *ProcessManualDialCallReq, opts ...grpc.CallOption) (*ProcessManualDialCallRes, error) {
	out := new(ProcessManualDialCallRes)
	err := c.cc.Invoke(ctx, CallQueue_ProcessManualDialCall_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *callQueueClient) DequeueCallForManualApproval(ctx context.Context, in *DequeueCallForManualApprovalReq, opts ...grpc.CallOption) (*DequeueCallForManualApprovalRes, error) {
	out := new(DequeueCallForManualApprovalRes)
	err := c.cc.Invoke(ctx, CallQueue_DequeueCallForManualApproval_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *callQueueClient) EnqueueManuallyApprovedCall(ctx context.Context, in *EnqueueManuallyApprovedCallReq, opts ...grpc.CallOption) (*EnqueueManuallyApprovedCallRes, error) {
	out := new(EnqueueManuallyApprovedCallRes)
	err := c.cc.Invoke(ctx, CallQueue_EnqueueManuallyApprovedCall_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *callQueueClient) EnqueueManuallyRejectedCall(ctx context.Context, in *EnqueueManuallyRejectedCallReq, opts ...grpc.CallOption) (*EnqueueManuallyRejectedCallRes, error) {
	out := new(EnqueueManuallyRejectedCallRes)
	err := c.cc.Invoke(ctx, CallQueue_EnqueueManuallyRejectedCall_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *callQueueClient) RequeueManuallyApprovedCall(ctx context.Context, in *RequeueManuallyApprovedCallReq, opts ...grpc.CallOption) (*RequeueManuallyApprovedCallRes, error) {
	out := new(RequeueManuallyApprovedCallRes)
	err := c.cc.Invoke(ctx, CallQueue_RequeueManuallyApprovedCall_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *callQueueClient) EnqueueManuallyApprovedSms(ctx context.Context, in *EnqueueManuallyApprovedSmsReq, opts ...grpc.CallOption) (*EnqueueManuallyApprovedSmsRes, error) {
	out := new(EnqueueManuallyApprovedSmsRes)
	err := c.cc.Invoke(ctx, CallQueue_EnqueueManuallyApprovedSms_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *callQueueClient) EnqueueManuallyRejectedSms(ctx context.Context, in *EnqueueManuallyRejectedSmsReq, opts ...grpc.CallOption) (*EnqueueManuallyRejectedSmsRes, error) {
	out := new(EnqueueManuallyRejectedSmsRes)
	err := c.cc.Invoke(ctx, CallQueue_EnqueueManuallyRejectedSms_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *callQueueClient) RequeueManuallyApprovedSms(ctx context.Context, in *RequeueManuallyApprovedSmsReq, opts ...grpc.CallOption) (*RequeueManuallyApprovedSmsRes, error) {
	out := new(RequeueManuallyApprovedSmsRes)
	err := c.cc.Invoke(ctx, CallQueue_RequeueManuallyApprovedSms_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *callQueueClient) DequeueSmsMamForManualApproval(ctx context.Context, in *DequeueSmsMamForManualApprovalReq, opts ...grpc.CallOption) (*DequeueSmsMamForManualApprovalRes, error) {
	out := new(DequeueSmsMamForManualApprovalRes)
	err := c.cc.Invoke(ctx, CallQueue_DequeueSmsMamForManualApproval_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CallQueueServer is the server API for CallQueue service.
// All implementations must embed UnimplementedCallQueueServer
// for forward compatibility
type CallQueueServer interface {
	// Returns either a preview record or preview call from one of multiple queues,
	// it also returns a field for the queue name so record/call can be enqueued back to the same queue.
	// It checks for a record first, if no record is dequeued, then the preview call queues will be checked.
	DequeuePreviewRecordOrCall(context.Context, *DequeuePreviewRecordOrCallReq) (*DequeuePreviewRecordOrCallRes, error)
	// Enqueues the given preview record into the specified queue.
	EnqueuePreviewRecord(context.Context, *EnqueuePreviewRecordReq) (*EnqueuePreviewRecordRes, error)
	// Returns the scrubbed simple call data for the given preview record.
	DequeueScrubbedCallForPreviewRecord(context.Context, *DequeueScrubbedCallForPreviewRecordReq) (*DequeueScrubbedCallForPreviewRecordRes, error)
	// Clears the preview record return queue for the requesting agent.
	ClearPreviewRecordReturnQueue(context.Context, *ClearPreviewRecordReturnQueueReq) (*ClearPreviewRecordReturnQueueRes, error)
	// Enqueues the given preview dial call into the specified queue.
	EnqueuePreviewDialCall(context.Context, *EnqueuePreviewDialCallReq) (*EnqueuePreviewDialCallRes, error)
	// Clears the manual dial return queue of the requesting agent.
	ClearManualDialQueue(context.Context, *ClearManualDialQueueReq) (*ClearManualDialQueueRes, error)
	// Enqueues the call to the manual dial receive queue for scrubbing.
	// The call will then be added to the manual dial return queue of the requesting agent.
	// The scrubbed call is then dequeued from that agent's manual dial return queue and returned.
	ProcessManualDialCall(context.Context, *ProcessManualDialCallReq) (*ProcessManualDialCallRes, error)
	// Dequeues a call for manual approval from the requesting agent's hunt group queues or a client queue,
	// it also returns a field for the queue name so call can be enqueued back to the same queue.
	DequeueCallForManualApproval(context.Context, *DequeueCallForManualApprovalReq) (*DequeueCallForManualApprovalRes, error)
	// Enqueues a call in the MAC approval queue.
	EnqueueManuallyApprovedCall(context.Context, *EnqueueManuallyApprovedCallReq) (*EnqueueManuallyApprovedCallRes, error)
	// Enqueues a call in the MAC rejection queue.
	EnqueueManuallyRejectedCall(context.Context, *EnqueueManuallyRejectedCallReq) (*EnqueueManuallyRejectedCallRes, error)
	// Requeues a call requiring manual approval to the specified queue.
	RequeueManuallyApprovedCall(context.Context, *RequeueManuallyApprovedCallReq) (*RequeueManuallyApprovedCallRes, error)
	// Enqueues sms msg in the MAM approval queue.
	EnqueueManuallyApprovedSms(context.Context, *EnqueueManuallyApprovedSmsReq) (*EnqueueManuallyApprovedSmsRes, error)
	// Enqueues sms msg in the MAM rejection queue.
	EnqueueManuallyRejectedSms(context.Context, *EnqueueManuallyRejectedSmsReq) (*EnqueueManuallyRejectedSmsRes, error)
	// Requeues sms msg requiring manual approval to the specified queue.
	RequeueManuallyApprovedSms(context.Context, *RequeueManuallyApprovedSmsReq) (*RequeueManuallyApprovedSmsRes, error)
	// Dequeues a sms mam msg for manual approval from the requesting agent's hunt group queues or a client queue,
	// it also returns a field for the queue name so sms mam msg can be enqueued back to the same queue.
	DequeueSmsMamForManualApproval(context.Context, *DequeueSmsMamForManualApprovalReq) (*DequeueSmsMamForManualApprovalRes, error)
	mustEmbedUnimplementedCallQueueServer()
}

// UnimplementedCallQueueServer must be embedded to have forward compatible implementations.
type UnimplementedCallQueueServer struct {
}

func (UnimplementedCallQueueServer) DequeuePreviewRecordOrCall(context.Context, *DequeuePreviewRecordOrCallReq) (*DequeuePreviewRecordOrCallRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DequeuePreviewRecordOrCall not implemented")
}
func (UnimplementedCallQueueServer) EnqueuePreviewRecord(context.Context, *EnqueuePreviewRecordReq) (*EnqueuePreviewRecordRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnqueuePreviewRecord not implemented")
}
func (UnimplementedCallQueueServer) DequeueScrubbedCallForPreviewRecord(context.Context, *DequeueScrubbedCallForPreviewRecordReq) (*DequeueScrubbedCallForPreviewRecordRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DequeueScrubbedCallForPreviewRecord not implemented")
}
func (UnimplementedCallQueueServer) ClearPreviewRecordReturnQueue(context.Context, *ClearPreviewRecordReturnQueueReq) (*ClearPreviewRecordReturnQueueRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearPreviewRecordReturnQueue not implemented")
}
func (UnimplementedCallQueueServer) EnqueuePreviewDialCall(context.Context, *EnqueuePreviewDialCallReq) (*EnqueuePreviewDialCallRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnqueuePreviewDialCall not implemented")
}
func (UnimplementedCallQueueServer) ClearManualDialQueue(context.Context, *ClearManualDialQueueReq) (*ClearManualDialQueueRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ClearManualDialQueue not implemented")
}
func (UnimplementedCallQueueServer) ProcessManualDialCall(context.Context, *ProcessManualDialCallReq) (*ProcessManualDialCallRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessManualDialCall not implemented")
}
func (UnimplementedCallQueueServer) DequeueCallForManualApproval(context.Context, *DequeueCallForManualApprovalReq) (*DequeueCallForManualApprovalRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DequeueCallForManualApproval not implemented")
}
func (UnimplementedCallQueueServer) EnqueueManuallyApprovedCall(context.Context, *EnqueueManuallyApprovedCallReq) (*EnqueueManuallyApprovedCallRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnqueueManuallyApprovedCall not implemented")
}
func (UnimplementedCallQueueServer) EnqueueManuallyRejectedCall(context.Context, *EnqueueManuallyRejectedCallReq) (*EnqueueManuallyRejectedCallRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnqueueManuallyRejectedCall not implemented")
}
func (UnimplementedCallQueueServer) RequeueManuallyApprovedCall(context.Context, *RequeueManuallyApprovedCallReq) (*RequeueManuallyApprovedCallRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequeueManuallyApprovedCall not implemented")
}
func (UnimplementedCallQueueServer) EnqueueManuallyApprovedSms(context.Context, *EnqueueManuallyApprovedSmsReq) (*EnqueueManuallyApprovedSmsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnqueueManuallyApprovedSms not implemented")
}
func (UnimplementedCallQueueServer) EnqueueManuallyRejectedSms(context.Context, *EnqueueManuallyRejectedSmsReq) (*EnqueueManuallyRejectedSmsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnqueueManuallyRejectedSms not implemented")
}
func (UnimplementedCallQueueServer) RequeueManuallyApprovedSms(context.Context, *RequeueManuallyApprovedSmsReq) (*RequeueManuallyApprovedSmsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequeueManuallyApprovedSms not implemented")
}
func (UnimplementedCallQueueServer) DequeueSmsMamForManualApproval(context.Context, *DequeueSmsMamForManualApprovalReq) (*DequeueSmsMamForManualApprovalRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DequeueSmsMamForManualApproval not implemented")
}
func (UnimplementedCallQueueServer) mustEmbedUnimplementedCallQueueServer() {}

// UnsafeCallQueueServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CallQueueServer will
// result in compilation errors.
type UnsafeCallQueueServer interface {
	mustEmbedUnimplementedCallQueueServer()
}

func RegisterCallQueueServer(s grpc.ServiceRegistrar, srv CallQueueServer) {
	s.RegisterService(&CallQueue_ServiceDesc, srv)
}

func _CallQueue_DequeuePreviewRecordOrCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DequeuePreviewRecordOrCallReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CallQueueServer).DequeuePreviewRecordOrCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CallQueue_DequeuePreviewRecordOrCall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CallQueueServer).DequeuePreviewRecordOrCall(ctx, req.(*DequeuePreviewRecordOrCallReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CallQueue_EnqueuePreviewRecord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnqueuePreviewRecordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CallQueueServer).EnqueuePreviewRecord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CallQueue_EnqueuePreviewRecord_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CallQueueServer).EnqueuePreviewRecord(ctx, req.(*EnqueuePreviewRecordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CallQueue_DequeueScrubbedCallForPreviewRecord_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DequeueScrubbedCallForPreviewRecordReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CallQueueServer).DequeueScrubbedCallForPreviewRecord(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CallQueue_DequeueScrubbedCallForPreviewRecord_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CallQueueServer).DequeueScrubbedCallForPreviewRecord(ctx, req.(*DequeueScrubbedCallForPreviewRecordReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CallQueue_ClearPreviewRecordReturnQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearPreviewRecordReturnQueueReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CallQueueServer).ClearPreviewRecordReturnQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CallQueue_ClearPreviewRecordReturnQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CallQueueServer).ClearPreviewRecordReturnQueue(ctx, req.(*ClearPreviewRecordReturnQueueReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CallQueue_EnqueuePreviewDialCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnqueuePreviewDialCallReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CallQueueServer).EnqueuePreviewDialCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CallQueue_EnqueuePreviewDialCall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CallQueueServer).EnqueuePreviewDialCall(ctx, req.(*EnqueuePreviewDialCallReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CallQueue_ClearManualDialQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ClearManualDialQueueReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CallQueueServer).ClearManualDialQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CallQueue_ClearManualDialQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CallQueueServer).ClearManualDialQueue(ctx, req.(*ClearManualDialQueueReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CallQueue_ProcessManualDialCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessManualDialCallReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CallQueueServer).ProcessManualDialCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CallQueue_ProcessManualDialCall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CallQueueServer).ProcessManualDialCall(ctx, req.(*ProcessManualDialCallReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CallQueue_DequeueCallForManualApproval_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DequeueCallForManualApprovalReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CallQueueServer).DequeueCallForManualApproval(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CallQueue_DequeueCallForManualApproval_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CallQueueServer).DequeueCallForManualApproval(ctx, req.(*DequeueCallForManualApprovalReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CallQueue_EnqueueManuallyApprovedCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnqueueManuallyApprovedCallReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CallQueueServer).EnqueueManuallyApprovedCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CallQueue_EnqueueManuallyApprovedCall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CallQueueServer).EnqueueManuallyApprovedCall(ctx, req.(*EnqueueManuallyApprovedCallReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CallQueue_EnqueueManuallyRejectedCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnqueueManuallyRejectedCallReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CallQueueServer).EnqueueManuallyRejectedCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CallQueue_EnqueueManuallyRejectedCall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CallQueueServer).EnqueueManuallyRejectedCall(ctx, req.(*EnqueueManuallyRejectedCallReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CallQueue_RequeueManuallyApprovedCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequeueManuallyApprovedCallReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CallQueueServer).RequeueManuallyApprovedCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CallQueue_RequeueManuallyApprovedCall_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CallQueueServer).RequeueManuallyApprovedCall(ctx, req.(*RequeueManuallyApprovedCallReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CallQueue_EnqueueManuallyApprovedSms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnqueueManuallyApprovedSmsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CallQueueServer).EnqueueManuallyApprovedSms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CallQueue_EnqueueManuallyApprovedSms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CallQueueServer).EnqueueManuallyApprovedSms(ctx, req.(*EnqueueManuallyApprovedSmsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CallQueue_EnqueueManuallyRejectedSms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnqueueManuallyRejectedSmsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CallQueueServer).EnqueueManuallyRejectedSms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CallQueue_EnqueueManuallyRejectedSms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CallQueueServer).EnqueueManuallyRejectedSms(ctx, req.(*EnqueueManuallyRejectedSmsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CallQueue_RequeueManuallyApprovedSms_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequeueManuallyApprovedSmsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CallQueueServer).RequeueManuallyApprovedSms(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CallQueue_RequeueManuallyApprovedSms_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CallQueueServer).RequeueManuallyApprovedSms(ctx, req.(*RequeueManuallyApprovedSmsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CallQueue_DequeueSmsMamForManualApproval_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DequeueSmsMamForManualApprovalReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CallQueueServer).DequeueSmsMamForManualApproval(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CallQueue_DequeueSmsMamForManualApproval_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CallQueueServer).DequeueSmsMamForManualApproval(ctx, req.(*DequeueSmsMamForManualApprovalReq))
	}
	return interceptor(ctx, in, info, handler)
}

// CallQueue_ServiceDesc is the grpc.ServiceDesc for CallQueue service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CallQueue_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.v0alpha.CallQueue",
	HandlerType: (*CallQueueServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DequeuePreviewRecordOrCall",
			Handler:    _CallQueue_DequeuePreviewRecordOrCall_Handler,
		},
		{
			MethodName: "EnqueuePreviewRecord",
			Handler:    _CallQueue_EnqueuePreviewRecord_Handler,
		},
		{
			MethodName: "DequeueScrubbedCallForPreviewRecord",
			Handler:    _CallQueue_DequeueScrubbedCallForPreviewRecord_Handler,
		},
		{
			MethodName: "ClearPreviewRecordReturnQueue",
			Handler:    _CallQueue_ClearPreviewRecordReturnQueue_Handler,
		},
		{
			MethodName: "EnqueuePreviewDialCall",
			Handler:    _CallQueue_EnqueuePreviewDialCall_Handler,
		},
		{
			MethodName: "ClearManualDialQueue",
			Handler:    _CallQueue_ClearManualDialQueue_Handler,
		},
		{
			MethodName: "ProcessManualDialCall",
			Handler:    _CallQueue_ProcessManualDialCall_Handler,
		},
		{
			MethodName: "DequeueCallForManualApproval",
			Handler:    _CallQueue_DequeueCallForManualApproval_Handler,
		},
		{
			MethodName: "EnqueueManuallyApprovedCall",
			Handler:    _CallQueue_EnqueueManuallyApprovedCall_Handler,
		},
		{
			MethodName: "EnqueueManuallyRejectedCall",
			Handler:    _CallQueue_EnqueueManuallyRejectedCall_Handler,
		},
		{
			MethodName: "RequeueManuallyApprovedCall",
			Handler:    _CallQueue_RequeueManuallyApprovedCall_Handler,
		},
		{
			MethodName: "EnqueueManuallyApprovedSms",
			Handler:    _CallQueue_EnqueueManuallyApprovedSms_Handler,
		},
		{
			MethodName: "EnqueueManuallyRejectedSms",
			Handler:    _CallQueue_EnqueueManuallyRejectedSms_Handler,
		},
		{
			MethodName: "RequeueManuallyApprovedSms",
			Handler:    _CallQueue_RequeueManuallyApprovedSms_Handler,
		},
		{
			MethodName: "DequeueSmsMamForManualApproval",
			Handler:    _CallQueue_DequeueSmsMamForManualApproval_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v0alpha/callqueue.proto",
}
