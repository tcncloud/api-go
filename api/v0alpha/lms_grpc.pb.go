// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.4.0
// - protoc             (unknown)
// source: api/v0alpha/lms.proto

package v0alpha

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	LMS_GetPublicKey_FullMethodName                     = "/api.v0alpha.LMS/GetPublicKey"
	LMS_CreateFileTemplate_FullMethodName               = "/api.v0alpha.LMS/CreateFileTemplate"
	LMS_ListFileTemplates_FullMethodName                = "/api.v0alpha.LMS/ListFileTemplates"
	LMS_UpdateFileTemplate_FullMethodName               = "/api.v0alpha.LMS/UpdateFileTemplate"
	LMS_DeleteFileTemplate_FullMethodName               = "/api.v0alpha.LMS/DeleteFileTemplate"
	LMS_GetFileTemplate_FullMethodName                  = "/api.v0alpha.LMS/GetFileTemplate"
	LMS_CreateField_FullMethodName                      = "/api.v0alpha.LMS/CreateField"
	LMS_ListFields_FullMethodName                       = "/api.v0alpha.LMS/ListFields"
	LMS_GetField_FullMethodName                         = "/api.v0alpha.LMS/GetField"
	LMS_UpdateField_FullMethodName                      = "/api.v0alpha.LMS/UpdateField"
	LMS_DeleteField_FullMethodName                      = "/api.v0alpha.LMS/DeleteField"
	LMS_ListAvailableFieldsByElementId_FullMethodName   = "/api.v0alpha.LMS/ListAvailableFieldsByElementId"
	LMS_ListFieldsForElement_FullMethodName             = "/api.v0alpha.LMS/ListFieldsForElement"
	LMS_ListAutocompleteFields_FullMethodName           = "/api.v0alpha.LMS/ListAutocompleteFields"
	LMS_ListCampaignLinks_FullMethodName                = "/api.v0alpha.LMS/ListCampaignLinks"
	LMS_PeekList_FullMethodName                         = "/api.v0alpha.LMS/PeekList"
	LMS_GetHistory_FullMethodName                       = "/api.v0alpha.LMS/GetHistory"
	LMS_CreateElement_FullMethodName                    = "/api.v0alpha.LMS/CreateElement"
	LMS_ListElements_FullMethodName                     = "/api.v0alpha.LMS/ListElements"
	LMS_GetElement_FullMethodName                       = "/api.v0alpha.LMS/GetElement"
	LMS_UpdateElement_FullMethodName                    = "/api.v0alpha.LMS/UpdateElement"
	LMS_DeleteElement_FullMethodName                    = "/api.v0alpha.LMS/DeleteElement"
	LMS_CopyPipelineUpstream_FullMethodName             = "/api.v0alpha.LMS/CopyPipelineUpstream"
	LMS_CopyPipelineDownstream_FullMethodName           = "/api.v0alpha.LMS/CopyPipelineDownstream"
	LMS_ProcessElement_FullMethodName                   = "/api.v0alpha.LMS/ProcessElement"
	LMS_ProcessList_FullMethodName                      = "/api.v0alpha.LMS/ProcessList"
	LMS_StreamList_FullMethodName                       = "/api.v0alpha.LMS/StreamList"
	LMS_GetAvailableFields_FullMethodName               = "/api.v0alpha.LMS/GetAvailableFields"
	LMS_ListNewEvents_FullMethodName                    = "/api.v0alpha.LMS/ListNewEvents"
	LMS_ViewQueue_FullMethodName                        = "/api.v0alpha.LMS/ViewQueue"
	LMS_Autocomplete_FullMethodName                     = "/api.v0alpha.LMS/Autocomplete"
	LMS_GetComplianceScrubLists_FullMethodName          = "/api.v0alpha.LMS/GetComplianceScrubLists"
	LMS_FindFieldUsages_FullMethodName                  = "/api.v0alpha.LMS/FindFieldUsages"
	LMS_FindInvalidElements_FullMethodName              = "/api.v0alpha.LMS/FindInvalidElements"
	LMS_CreateCollection_FullMethodName                 = "/api.v0alpha.LMS/CreateCollection"
	LMS_GetCollection_FullMethodName                    = "/api.v0alpha.LMS/GetCollection"
	LMS_UpdateCollection_FullMethodName                 = "/api.v0alpha.LMS/UpdateCollection"
	LMS_DeleteCollection_FullMethodName                 = "/api.v0alpha.LMS/DeleteCollection"
	LMS_ListCollections_FullMethodName                  = "/api.v0alpha.LMS/ListCollections"
	LMS_ResetCollection_FullMethodName                  = "/api.v0alpha.LMS/ResetCollection"
	LMS_AddCollectionEntry_FullMethodName               = "/api.v0alpha.LMS/AddCollectionEntry"
	LMS_DeleteCollectionEntry_FullMethodName            = "/api.v0alpha.LMS/DeleteCollectionEntry"
	LMS_UpdateCollectionEntry_FullMethodName            = "/api.v0alpha.LMS/UpdateCollectionEntry"
	LMS_StreamCollection_FullMethodName                 = "/api.v0alpha.LMS/StreamCollection"
	LMS_SearchCollectionsPaginated_FullMethodName       = "/api.v0alpha.LMS/SearchCollectionsPaginated"
	LMS_GetCollectionEntries_FullMethodName             = "/api.v0alpha.LMS/GetCollectionEntries"
	LMS_CreateCjsSearchDefinition_FullMethodName        = "/api.v0alpha.LMS/CreateCjsSearchDefinition"
	LMS_GetCjsSearchDefinition_FullMethodName           = "/api.v0alpha.LMS/GetCjsSearchDefinition"
	LMS_UpdateCjsSearchDefinition_FullMethodName        = "/api.v0alpha.LMS/UpdateCjsSearchDefinition"
	LMS_DeleteCjsSearchDefinition_FullMethodName        = "/api.v0alpha.LMS/DeleteCjsSearchDefinition"
	LMS_ListCjsSearchDefinitions_FullMethodName         = "/api.v0alpha.LMS/ListCjsSearchDefinitions"
	LMS_ExecuteCjsSearchDefinition_FullMethodName       = "/api.v0alpha.LMS/ExecuteCjsSearchDefinition"
	LMS_GetCjsSecureSearchCriteria_FullMethodName       = "/api.v0alpha.LMS/GetCjsSecureSearchCriteria"
	LMS_CreateCjsSecureSearchCriteria_FullMethodName    = "/api.v0alpha.LMS/CreateCjsSecureSearchCriteria"
	LMS_UpdateCjsSecureSearchCriteria_FullMethodName    = "/api.v0alpha.LMS/UpdateCjsSecureSearchCriteria"
	LMS_SampleEndpoint_FullMethodName                   = "/api.v0alpha.LMS/SampleEndpoint"
	LMS_GetAvailableEHRFields_FullMethodName            = "/api.v0alpha.LMS/GetAvailableEHRFields"
	LMS_GetQueuedEventsStatusByElementId_FullMethodName = "/api.v0alpha.LMS/GetQueuedEventsStatusByElementId"
	LMS_ListPools_FullMethodName                        = "/api.v0alpha.LMS/ListPools"
)

// LMSClient is the client API for LMS service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LMSClient interface {
	GetPublicKey(ctx context.Context, in *GetPublicKeyReq, opts ...grpc.CallOption) (*PublicKey, error)
	CreateFileTemplate(ctx context.Context, in *FileTemplate, opts ...grpc.CallOption) (*FileTemplate, error)
	ListFileTemplates(ctx context.Context, in *GetFileTemplatesReq, opts ...grpc.CallOption) (LMS_ListFileTemplatesClient, error)
	UpdateFileTemplate(ctx context.Context, in *FileTemplate, opts ...grpc.CallOption) (*FileTemplate, error)
	DeleteFileTemplate(ctx context.Context, in *FileTemplate, opts ...grpc.CallOption) (*FileTemplate, error)
	GetFileTemplate(ctx context.Context, in *FileTemplate, opts ...grpc.CallOption) (*FileTemplate, error)
	CreateField(ctx context.Context, in *Field, opts ...grpc.CallOption) (*Field, error)
	ListFields(ctx context.Context, in *ListFieldsReq, opts ...grpc.CallOption) (*Fields, error)
	GetField(ctx context.Context, in *Field, opts ...grpc.CallOption) (*Field, error)
	UpdateField(ctx context.Context, in *UpdateFieldReq, opts ...grpc.CallOption) (*Field, error)
	DeleteField(ctx context.Context, in *Field, opts ...grpc.CallOption) (*Field, error)
	ListAvailableFieldsByElementId(ctx context.Context, in *ListAvailableFieldsByElementIdReq, opts ...grpc.CallOption) (*ProcessFields, error)
	ListFieldsForElement(ctx context.Context, in *ListFieldsForElementReq, opts ...grpc.CallOption) (*ListFieldsForElementRes, error)
	ListAutocompleteFields(ctx context.Context, in *ListAutocompleteFieldsReq, opts ...grpc.CallOption) (*ListAutocompleteFieldsRes, error)
	// list campaign links and descriptions
	ListCampaignLinks(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListCampaignLinksRes, error)
	PeekList(ctx context.Context, in *PeekListReq, opts ...grpc.CallOption) (*PeekListRes, error)
	GetHistory(ctx context.Context, in *GetHistoryReq, opts ...grpc.CallOption) (*GetHistoryRes, error)
	CreateElement(ctx context.Context, in *Element, opts ...grpc.CallOption) (*Element, error)
	ListElements(ctx context.Context, in *ListElementsReq, opts ...grpc.CallOption) (LMS_ListElementsClient, error)
	GetElement(ctx context.Context, in *ElementPK, opts ...grpc.CallOption) (*Element, error)
	UpdateElement(ctx context.Context, in *Element, opts ...grpc.CallOption) (*Element, error)
	DeleteElement(ctx context.Context, in *Element, opts ...grpc.CallOption) (*Element, error)
	// CopyPipelineUpstream copies an Element and all of its' parents
	CopyPipelineUpstream(ctx context.Context, in *Element, opts ...grpc.CallOption) (LMS_CopyPipelineUpstreamClient, error)
	// CopyPipelineDownstream copies an Element and all of its' children
	CopyPipelineDownstream(ctx context.Context, in *Element, opts ...grpc.CallOption) (LMS_CopyPipelineDownstreamClient, error)
	ProcessElement(ctx context.Context, in *ProcessElementReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ProcessList(ctx context.Context, in *ProcessListRequest, opts ...grpc.CallOption) (*ProcessListResponse, error)
	StreamList(ctx context.Context, opts ...grpc.CallOption) (LMS_StreamListClient, error)
	GetAvailableFields(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ProcessFields, error)
	// returns queue events for the last 30 minutes
	ListNewEvents(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Events, error)
	ViewQueue(ctx context.Context, in *ViewQueueReq, opts ...grpc.CallOption) (*Events, error)
	Autocomplete(ctx context.Context, in *ParseReq, opts ...grpc.CallOption) (*ParseRes, error)
	GetComplianceScrubLists(ctx context.Context, in *GetComplianceScrubListsReq, opts ...grpc.CallOption) (*GetComplianceScrubListsRes, error)
	FindFieldUsages(ctx context.Context, in *FindFieldUsagesReq, opts ...grpc.CallOption) (*FindFieldUsagesRes, error)
	FindInvalidElements(ctx context.Context, in *FindInvalidElementsReq, opts ...grpc.CallOption) (*FindInvalidElementsRes, error)
	// CJS calls
	CreateCollection(ctx context.Context, in *CollectionMetadata, opts ...grpc.CallOption) (*CollectionMetadata, error)
	GetCollection(ctx context.Context, in *GetCollectionReq, opts ...grpc.CallOption) (*CollectionMetadata, error)
	UpdateCollection(ctx context.Context, in *CollectionMetadata, opts ...grpc.CallOption) (*emptypb.Empty, error)
	DeleteCollection(ctx context.Context, in *DeleteCollectionReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	ListCollections(ctx context.Context, in *ListCollectionsReq, opts ...grpc.CallOption) (*ListCollectionsRes, error)
	ResetCollection(ctx context.Context, in *ResetCollectionReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	AddCollectionEntry(ctx context.Context, in *CollectionEntry, opts ...grpc.CallOption) (*CollectionEntry, error)
	DeleteCollectionEntry(ctx context.Context, in *DeleteCollectionEntryReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	UpdateCollectionEntry(ctx context.Context, in *CollectionEntry, opts ...grpc.CallOption) (*CollectionEntry, error)
	// StreamCollection needs to be used in conjunction with GetCollection
	// to have the metadata associated with it
	StreamCollection(ctx context.Context, in *StreamCollectionReq, opts ...grpc.CallOption) (LMS_StreamCollectionClient, error)
	// SearchCollectionsWithQueryPaginated needs to be used in conjunction with GetCollection
	// to have the metadata associated with it
	SearchCollectionsPaginated(ctx context.Context, in *SearchCollectionsPaginatedReq, opts ...grpc.CallOption) (*PaginatedSearchRes, error)
	// GetCollectionEntries fetches a page (size specified by the page_size param) of entries for
	// the specified collection_id, org_id, region_id starting at location specified by from
	GetCollectionEntries(ctx context.Context, in *GetCollectionEntriesReq, opts ...grpc.CallOption) (*GetCollectionEntriesRes, error)
	// CreateCjsSearchDefinition creates a search definition
	CreateCjsSearchDefinition(ctx context.Context, in *CjsSearchDefinition, opts ...grpc.CallOption) (*CjsSearchDefinition, error)
	// GetCjsSearchDefinition gets the search definition specified by search_definition_id
	GetCjsSearchDefinition(ctx context.Context, in *GetCjsSearchDefinitionReq, opts ...grpc.CallOption) (*CjsSearchDefinition, error)
	// UpdateCjsSearchDefinition updates the search definition specified by search_definition_id
	UpdateCjsSearchDefinition(ctx context.Context, in *CjsSearchDefinition, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DeleteCjsSearchDefinition deletes the search definition specified by search_definition_id
	DeleteCjsSearchDefinition(ctx context.Context, in *DeleteCjsSearchDefinitionReq, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ListCjsSearchDefinitions lists the search definitions
	ListCjsSearchDefinitions(ctx context.Context, in *ListCjsSearchDefinitionsReq, opts ...grpc.CallOption) (*ListCjsSearchDefinitionsRes, error)
	// ExecuteCjsSearchDefinition executes the search definition specified by search_definition_id
	ExecuteCjsSearchDefinition(ctx context.Context, in *ExecuteCjsSearchDefinitionReq, opts ...grpc.CallOption) (*ExecuteCjsSearchDefinitionRes, error)
	// GetCjsSecureSearchCriteria gets the secure search criteria
	GetCjsSecureSearchCriteria(ctx context.Context, in *GetCjsSecureSearchCriteriaReq, opts ...grpc.CallOption) (*CjsSecureSearchCriteria, error)
	// CreateCjsSecureSearchCriteria creates a secure search criteria
	CreateCjsSecureSearchCriteria(ctx context.Context, in *CjsSecureSearchCriteria, opts ...grpc.CallOption) (*CjsSecureSearchCriteria, error)
	// UpdateCjsSecureSearchCriteria updates the secure search criteria
	UpdateCjsSecureSearchCriteria(ctx context.Context, in *CjsSecureSearchCriteria, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SampleEndpoint is to test that values come through to the api appropriately
	SampleEndpoint(ctx context.Context, in *SampleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// returns all fields possible that an ehr entity type could return (that we know of)
	GetAvailableEHRFields(ctx context.Context, in *EHREntityType, opts ...grpc.CallOption) (*Fields, error)
	GetQueuedEventsStatusByElementId(ctx context.Context, in *ElementPK, opts ...grpc.CallOption) (*Events, error)
	// List pools is a unary call to show finvi pools through exile
	ListPools(ctx context.Context, in *ListPoolsRequest, opts ...grpc.CallOption) (*ListPoolsResponse, error)
}

type lMSClient struct {
	cc grpc.ClientConnInterface
}

func NewLMSClient(cc grpc.ClientConnInterface) LMSClient {
	return &lMSClient{cc}
}

func (c *lMSClient) GetPublicKey(ctx context.Context, in *GetPublicKeyReq, opts ...grpc.CallOption) (*PublicKey, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublicKey)
	err := c.cc.Invoke(ctx, LMS_GetPublicKey_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) CreateFileTemplate(ctx context.Context, in *FileTemplate, opts ...grpc.CallOption) (*FileTemplate, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FileTemplate)
	err := c.cc.Invoke(ctx, LMS_CreateFileTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) ListFileTemplates(ctx context.Context, in *GetFileTemplatesReq, opts ...grpc.CallOption) (LMS_ListFileTemplatesClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LMS_ServiceDesc.Streams[0], LMS_ListFileTemplates_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &lMSListFileTemplatesClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LMS_ListFileTemplatesClient interface {
	Recv() (*FileTemplate, error)
	grpc.ClientStream
}

type lMSListFileTemplatesClient struct {
	grpc.ClientStream
}

func (x *lMSListFileTemplatesClient) Recv() (*FileTemplate, error) {
	m := new(FileTemplate)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lMSClient) UpdateFileTemplate(ctx context.Context, in *FileTemplate, opts ...grpc.CallOption) (*FileTemplate, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FileTemplate)
	err := c.cc.Invoke(ctx, LMS_UpdateFileTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) DeleteFileTemplate(ctx context.Context, in *FileTemplate, opts ...grpc.CallOption) (*FileTemplate, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FileTemplate)
	err := c.cc.Invoke(ctx, LMS_DeleteFileTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) GetFileTemplate(ctx context.Context, in *FileTemplate, opts ...grpc.CallOption) (*FileTemplate, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FileTemplate)
	err := c.cc.Invoke(ctx, LMS_GetFileTemplate_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) CreateField(ctx context.Context, in *Field, opts ...grpc.CallOption) (*Field, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Field)
	err := c.cc.Invoke(ctx, LMS_CreateField_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) ListFields(ctx context.Context, in *ListFieldsReq, opts ...grpc.CallOption) (*Fields, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Fields)
	err := c.cc.Invoke(ctx, LMS_ListFields_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) GetField(ctx context.Context, in *Field, opts ...grpc.CallOption) (*Field, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Field)
	err := c.cc.Invoke(ctx, LMS_GetField_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) UpdateField(ctx context.Context, in *UpdateFieldReq, opts ...grpc.CallOption) (*Field, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Field)
	err := c.cc.Invoke(ctx, LMS_UpdateField_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) DeleteField(ctx context.Context, in *Field, opts ...grpc.CallOption) (*Field, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Field)
	err := c.cc.Invoke(ctx, LMS_DeleteField_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) ListAvailableFieldsByElementId(ctx context.Context, in *ListAvailableFieldsByElementIdReq, opts ...grpc.CallOption) (*ProcessFields, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessFields)
	err := c.cc.Invoke(ctx, LMS_ListAvailableFieldsByElementId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) ListFieldsForElement(ctx context.Context, in *ListFieldsForElementReq, opts ...grpc.CallOption) (*ListFieldsForElementRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListFieldsForElementRes)
	err := c.cc.Invoke(ctx, LMS_ListFieldsForElement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) ListAutocompleteFields(ctx context.Context, in *ListAutocompleteFieldsReq, opts ...grpc.CallOption) (*ListAutocompleteFieldsRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListAutocompleteFieldsRes)
	err := c.cc.Invoke(ctx, LMS_ListAutocompleteFields_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) ListCampaignLinks(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ListCampaignLinksRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCampaignLinksRes)
	err := c.cc.Invoke(ctx, LMS_ListCampaignLinks_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) PeekList(ctx context.Context, in *PeekListReq, opts ...grpc.CallOption) (*PeekListRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PeekListRes)
	err := c.cc.Invoke(ctx, LMS_PeekList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) GetHistory(ctx context.Context, in *GetHistoryReq, opts ...grpc.CallOption) (*GetHistoryRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetHistoryRes)
	err := c.cc.Invoke(ctx, LMS_GetHistory_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) CreateElement(ctx context.Context, in *Element, opts ...grpc.CallOption) (*Element, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Element)
	err := c.cc.Invoke(ctx, LMS_CreateElement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) ListElements(ctx context.Context, in *ListElementsReq, opts ...grpc.CallOption) (LMS_ListElementsClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LMS_ServiceDesc.Streams[1], LMS_ListElements_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &lMSListElementsClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LMS_ListElementsClient interface {
	Recv() (*Element, error)
	grpc.ClientStream
}

type lMSListElementsClient struct {
	grpc.ClientStream
}

func (x *lMSListElementsClient) Recv() (*Element, error) {
	m := new(Element)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lMSClient) GetElement(ctx context.Context, in *ElementPK, opts ...grpc.CallOption) (*Element, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Element)
	err := c.cc.Invoke(ctx, LMS_GetElement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) UpdateElement(ctx context.Context, in *Element, opts ...grpc.CallOption) (*Element, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Element)
	err := c.cc.Invoke(ctx, LMS_UpdateElement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) DeleteElement(ctx context.Context, in *Element, opts ...grpc.CallOption) (*Element, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Element)
	err := c.cc.Invoke(ctx, LMS_DeleteElement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) CopyPipelineUpstream(ctx context.Context, in *Element, opts ...grpc.CallOption) (LMS_CopyPipelineUpstreamClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LMS_ServiceDesc.Streams[2], LMS_CopyPipelineUpstream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &lMSCopyPipelineUpstreamClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LMS_CopyPipelineUpstreamClient interface {
	Recv() (*Element, error)
	grpc.ClientStream
}

type lMSCopyPipelineUpstreamClient struct {
	grpc.ClientStream
}

func (x *lMSCopyPipelineUpstreamClient) Recv() (*Element, error) {
	m := new(Element)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lMSClient) CopyPipelineDownstream(ctx context.Context, in *Element, opts ...grpc.CallOption) (LMS_CopyPipelineDownstreamClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LMS_ServiceDesc.Streams[3], LMS_CopyPipelineDownstream_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &lMSCopyPipelineDownstreamClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LMS_CopyPipelineDownstreamClient interface {
	Recv() (*Element, error)
	grpc.ClientStream
}

type lMSCopyPipelineDownstreamClient struct {
	grpc.ClientStream
}

func (x *lMSCopyPipelineDownstreamClient) Recv() (*Element, error) {
	m := new(Element)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lMSClient) ProcessElement(ctx context.Context, in *ProcessElementReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, LMS_ProcessElement_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) ProcessList(ctx context.Context, in *ProcessListRequest, opts ...grpc.CallOption) (*ProcessListResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessListResponse)
	err := c.cc.Invoke(ctx, LMS_ProcessList_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) StreamList(ctx context.Context, opts ...grpc.CallOption) (LMS_StreamListClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LMS_ServiceDesc.Streams[4], LMS_StreamList_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &lMSStreamListClient{ClientStream: stream}
	return x, nil
}

type LMS_StreamListClient interface {
	Send(*StreamListRequest) error
	CloseAndRecv() (*StreamListResponse, error)
	grpc.ClientStream
}

type lMSStreamListClient struct {
	grpc.ClientStream
}

func (x *lMSStreamListClient) Send(m *StreamListRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *lMSStreamListClient) CloseAndRecv() (*StreamListResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(StreamListResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lMSClient) GetAvailableFields(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*ProcessFields, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ProcessFields)
	err := c.cc.Invoke(ctx, LMS_GetAvailableFields_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) ListNewEvents(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*Events, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Events)
	err := c.cc.Invoke(ctx, LMS_ListNewEvents_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) ViewQueue(ctx context.Context, in *ViewQueueReq, opts ...grpc.CallOption) (*Events, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Events)
	err := c.cc.Invoke(ctx, LMS_ViewQueue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) Autocomplete(ctx context.Context, in *ParseReq, opts ...grpc.CallOption) (*ParseRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ParseRes)
	err := c.cc.Invoke(ctx, LMS_Autocomplete_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) GetComplianceScrubLists(ctx context.Context, in *GetComplianceScrubListsReq, opts ...grpc.CallOption) (*GetComplianceScrubListsRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetComplianceScrubListsRes)
	err := c.cc.Invoke(ctx, LMS_GetComplianceScrubLists_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) FindFieldUsages(ctx context.Context, in *FindFieldUsagesReq, opts ...grpc.CallOption) (*FindFieldUsagesRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindFieldUsagesRes)
	err := c.cc.Invoke(ctx, LMS_FindFieldUsages_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) FindInvalidElements(ctx context.Context, in *FindInvalidElementsReq, opts ...grpc.CallOption) (*FindInvalidElementsRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(FindInvalidElementsRes)
	err := c.cc.Invoke(ctx, LMS_FindInvalidElements_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) CreateCollection(ctx context.Context, in *CollectionMetadata, opts ...grpc.CallOption) (*CollectionMetadata, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CollectionMetadata)
	err := c.cc.Invoke(ctx, LMS_CreateCollection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) GetCollection(ctx context.Context, in *GetCollectionReq, opts ...grpc.CallOption) (*CollectionMetadata, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CollectionMetadata)
	err := c.cc.Invoke(ctx, LMS_GetCollection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) UpdateCollection(ctx context.Context, in *CollectionMetadata, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, LMS_UpdateCollection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) DeleteCollection(ctx context.Context, in *DeleteCollectionReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, LMS_DeleteCollection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) ListCollections(ctx context.Context, in *ListCollectionsReq, opts ...grpc.CallOption) (*ListCollectionsRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCollectionsRes)
	err := c.cc.Invoke(ctx, LMS_ListCollections_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) ResetCollection(ctx context.Context, in *ResetCollectionReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, LMS_ResetCollection_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) AddCollectionEntry(ctx context.Context, in *CollectionEntry, opts ...grpc.CallOption) (*CollectionEntry, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CollectionEntry)
	err := c.cc.Invoke(ctx, LMS_AddCollectionEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) DeleteCollectionEntry(ctx context.Context, in *DeleteCollectionEntryReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, LMS_DeleteCollectionEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) UpdateCollectionEntry(ctx context.Context, in *CollectionEntry, opts ...grpc.CallOption) (*CollectionEntry, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CollectionEntry)
	err := c.cc.Invoke(ctx, LMS_UpdateCollectionEntry_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) StreamCollection(ctx context.Context, in *StreamCollectionReq, opts ...grpc.CallOption) (LMS_StreamCollectionClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &LMS_ServiceDesc.Streams[5], LMS_StreamCollection_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &lMSStreamCollectionClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type LMS_StreamCollectionClient interface {
	Recv() (*CollectionEntry, error)
	grpc.ClientStream
}

type lMSStreamCollectionClient struct {
	grpc.ClientStream
}

func (x *lMSStreamCollectionClient) Recv() (*CollectionEntry, error) {
	m := new(CollectionEntry)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *lMSClient) SearchCollectionsPaginated(ctx context.Context, in *SearchCollectionsPaginatedReq, opts ...grpc.CallOption) (*PaginatedSearchRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PaginatedSearchRes)
	err := c.cc.Invoke(ctx, LMS_SearchCollectionsPaginated_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) GetCollectionEntries(ctx context.Context, in *GetCollectionEntriesReq, opts ...grpc.CallOption) (*GetCollectionEntriesRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetCollectionEntriesRes)
	err := c.cc.Invoke(ctx, LMS_GetCollectionEntries_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) CreateCjsSearchDefinition(ctx context.Context, in *CjsSearchDefinition, opts ...grpc.CallOption) (*CjsSearchDefinition, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CjsSearchDefinition)
	err := c.cc.Invoke(ctx, LMS_CreateCjsSearchDefinition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) GetCjsSearchDefinition(ctx context.Context, in *GetCjsSearchDefinitionReq, opts ...grpc.CallOption) (*CjsSearchDefinition, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CjsSearchDefinition)
	err := c.cc.Invoke(ctx, LMS_GetCjsSearchDefinition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) UpdateCjsSearchDefinition(ctx context.Context, in *CjsSearchDefinition, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, LMS_UpdateCjsSearchDefinition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) DeleteCjsSearchDefinition(ctx context.Context, in *DeleteCjsSearchDefinitionReq, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, LMS_DeleteCjsSearchDefinition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) ListCjsSearchDefinitions(ctx context.Context, in *ListCjsSearchDefinitionsReq, opts ...grpc.CallOption) (*ListCjsSearchDefinitionsRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListCjsSearchDefinitionsRes)
	err := c.cc.Invoke(ctx, LMS_ListCjsSearchDefinitions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) ExecuteCjsSearchDefinition(ctx context.Context, in *ExecuteCjsSearchDefinitionReq, opts ...grpc.CallOption) (*ExecuteCjsSearchDefinitionRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ExecuteCjsSearchDefinitionRes)
	err := c.cc.Invoke(ctx, LMS_ExecuteCjsSearchDefinition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) GetCjsSecureSearchCriteria(ctx context.Context, in *GetCjsSecureSearchCriteriaReq, opts ...grpc.CallOption) (*CjsSecureSearchCriteria, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CjsSecureSearchCriteria)
	err := c.cc.Invoke(ctx, LMS_GetCjsSecureSearchCriteria_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) CreateCjsSecureSearchCriteria(ctx context.Context, in *CjsSecureSearchCriteria, opts ...grpc.CallOption) (*CjsSecureSearchCriteria, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CjsSecureSearchCriteria)
	err := c.cc.Invoke(ctx, LMS_CreateCjsSecureSearchCriteria_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) UpdateCjsSecureSearchCriteria(ctx context.Context, in *CjsSecureSearchCriteria, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, LMS_UpdateCjsSecureSearchCriteria_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) SampleEndpoint(ctx context.Context, in *SampleRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, LMS_SampleEndpoint_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) GetAvailableEHRFields(ctx context.Context, in *EHREntityType, opts ...grpc.CallOption) (*Fields, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Fields)
	err := c.cc.Invoke(ctx, LMS_GetAvailableEHRFields_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) GetQueuedEventsStatusByElementId(ctx context.Context, in *ElementPK, opts ...grpc.CallOption) (*Events, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(Events)
	err := c.cc.Invoke(ctx, LMS_GetQueuedEventsStatusByElementId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *lMSClient) ListPools(ctx context.Context, in *ListPoolsRequest, opts ...grpc.CallOption) (*ListPoolsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPoolsResponse)
	err := c.cc.Invoke(ctx, LMS_ListPools_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LMSServer is the server API for LMS service.
// All implementations must embed UnimplementedLMSServer
// for forward compatibility
type LMSServer interface {
	GetPublicKey(context.Context, *GetPublicKeyReq) (*PublicKey, error)
	CreateFileTemplate(context.Context, *FileTemplate) (*FileTemplate, error)
	ListFileTemplates(*GetFileTemplatesReq, LMS_ListFileTemplatesServer) error
	UpdateFileTemplate(context.Context, *FileTemplate) (*FileTemplate, error)
	DeleteFileTemplate(context.Context, *FileTemplate) (*FileTemplate, error)
	GetFileTemplate(context.Context, *FileTemplate) (*FileTemplate, error)
	CreateField(context.Context, *Field) (*Field, error)
	ListFields(context.Context, *ListFieldsReq) (*Fields, error)
	GetField(context.Context, *Field) (*Field, error)
	UpdateField(context.Context, *UpdateFieldReq) (*Field, error)
	DeleteField(context.Context, *Field) (*Field, error)
	ListAvailableFieldsByElementId(context.Context, *ListAvailableFieldsByElementIdReq) (*ProcessFields, error)
	ListFieldsForElement(context.Context, *ListFieldsForElementReq) (*ListFieldsForElementRes, error)
	ListAutocompleteFields(context.Context, *ListAutocompleteFieldsReq) (*ListAutocompleteFieldsRes, error)
	// list campaign links and descriptions
	ListCampaignLinks(context.Context, *emptypb.Empty) (*ListCampaignLinksRes, error)
	PeekList(context.Context, *PeekListReq) (*PeekListRes, error)
	GetHistory(context.Context, *GetHistoryReq) (*GetHistoryRes, error)
	CreateElement(context.Context, *Element) (*Element, error)
	ListElements(*ListElementsReq, LMS_ListElementsServer) error
	GetElement(context.Context, *ElementPK) (*Element, error)
	UpdateElement(context.Context, *Element) (*Element, error)
	DeleteElement(context.Context, *Element) (*Element, error)
	// CopyPipelineUpstream copies an Element and all of its' parents
	CopyPipelineUpstream(*Element, LMS_CopyPipelineUpstreamServer) error
	// CopyPipelineDownstream copies an Element and all of its' children
	CopyPipelineDownstream(*Element, LMS_CopyPipelineDownstreamServer) error
	ProcessElement(context.Context, *ProcessElementReq) (*emptypb.Empty, error)
	ProcessList(context.Context, *ProcessListRequest) (*ProcessListResponse, error)
	StreamList(LMS_StreamListServer) error
	GetAvailableFields(context.Context, *emptypb.Empty) (*ProcessFields, error)
	// returns queue events for the last 30 minutes
	ListNewEvents(context.Context, *emptypb.Empty) (*Events, error)
	ViewQueue(context.Context, *ViewQueueReq) (*Events, error)
	Autocomplete(context.Context, *ParseReq) (*ParseRes, error)
	GetComplianceScrubLists(context.Context, *GetComplianceScrubListsReq) (*GetComplianceScrubListsRes, error)
	FindFieldUsages(context.Context, *FindFieldUsagesReq) (*FindFieldUsagesRes, error)
	FindInvalidElements(context.Context, *FindInvalidElementsReq) (*FindInvalidElementsRes, error)
	// CJS calls
	CreateCollection(context.Context, *CollectionMetadata) (*CollectionMetadata, error)
	GetCollection(context.Context, *GetCollectionReq) (*CollectionMetadata, error)
	UpdateCollection(context.Context, *CollectionMetadata) (*emptypb.Empty, error)
	DeleteCollection(context.Context, *DeleteCollectionReq) (*emptypb.Empty, error)
	ListCollections(context.Context, *ListCollectionsReq) (*ListCollectionsRes, error)
	ResetCollection(context.Context, *ResetCollectionReq) (*emptypb.Empty, error)
	AddCollectionEntry(context.Context, *CollectionEntry) (*CollectionEntry, error)
	DeleteCollectionEntry(context.Context, *DeleteCollectionEntryReq) (*emptypb.Empty, error)
	UpdateCollectionEntry(context.Context, *CollectionEntry) (*CollectionEntry, error)
	// StreamCollection needs to be used in conjunction with GetCollection
	// to have the metadata associated with it
	StreamCollection(*StreamCollectionReq, LMS_StreamCollectionServer) error
	// SearchCollectionsWithQueryPaginated needs to be used in conjunction with GetCollection
	// to have the metadata associated with it
	SearchCollectionsPaginated(context.Context, *SearchCollectionsPaginatedReq) (*PaginatedSearchRes, error)
	// GetCollectionEntries fetches a page (size specified by the page_size param) of entries for
	// the specified collection_id, org_id, region_id starting at location specified by from
	GetCollectionEntries(context.Context, *GetCollectionEntriesReq) (*GetCollectionEntriesRes, error)
	// CreateCjsSearchDefinition creates a search definition
	CreateCjsSearchDefinition(context.Context, *CjsSearchDefinition) (*CjsSearchDefinition, error)
	// GetCjsSearchDefinition gets the search definition specified by search_definition_id
	GetCjsSearchDefinition(context.Context, *GetCjsSearchDefinitionReq) (*CjsSearchDefinition, error)
	// UpdateCjsSearchDefinition updates the search definition specified by search_definition_id
	UpdateCjsSearchDefinition(context.Context, *CjsSearchDefinition) (*emptypb.Empty, error)
	// DeleteCjsSearchDefinition deletes the search definition specified by search_definition_id
	DeleteCjsSearchDefinition(context.Context, *DeleteCjsSearchDefinitionReq) (*emptypb.Empty, error)
	// ListCjsSearchDefinitions lists the search definitions
	ListCjsSearchDefinitions(context.Context, *ListCjsSearchDefinitionsReq) (*ListCjsSearchDefinitionsRes, error)
	// ExecuteCjsSearchDefinition executes the search definition specified by search_definition_id
	ExecuteCjsSearchDefinition(context.Context, *ExecuteCjsSearchDefinitionReq) (*ExecuteCjsSearchDefinitionRes, error)
	// GetCjsSecureSearchCriteria gets the secure search criteria
	GetCjsSecureSearchCriteria(context.Context, *GetCjsSecureSearchCriteriaReq) (*CjsSecureSearchCriteria, error)
	// CreateCjsSecureSearchCriteria creates a secure search criteria
	CreateCjsSecureSearchCriteria(context.Context, *CjsSecureSearchCriteria) (*CjsSecureSearchCriteria, error)
	// UpdateCjsSecureSearchCriteria updates the secure search criteria
	UpdateCjsSecureSearchCriteria(context.Context, *CjsSecureSearchCriteria) (*emptypb.Empty, error)
	// SampleEndpoint is to test that values come through to the api appropriately
	SampleEndpoint(context.Context, *SampleRequest) (*emptypb.Empty, error)
	// returns all fields possible that an ehr entity type could return (that we know of)
	GetAvailableEHRFields(context.Context, *EHREntityType) (*Fields, error)
	GetQueuedEventsStatusByElementId(context.Context, *ElementPK) (*Events, error)
	// List pools is a unary call to show finvi pools through exile
	ListPools(context.Context, *ListPoolsRequest) (*ListPoolsResponse, error)
	mustEmbedUnimplementedLMSServer()
}

// UnimplementedLMSServer must be embedded to have forward compatible implementations.
type UnimplementedLMSServer struct {
}

func (UnimplementedLMSServer) GetPublicKey(context.Context, *GetPublicKeyReq) (*PublicKey, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPublicKey not implemented")
}
func (UnimplementedLMSServer) CreateFileTemplate(context.Context, *FileTemplate) (*FileTemplate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateFileTemplate not implemented")
}
func (UnimplementedLMSServer) ListFileTemplates(*GetFileTemplatesReq, LMS_ListFileTemplatesServer) error {
	return status.Errorf(codes.Unimplemented, "method ListFileTemplates not implemented")
}
func (UnimplementedLMSServer) UpdateFileTemplate(context.Context, *FileTemplate) (*FileTemplate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateFileTemplate not implemented")
}
func (UnimplementedLMSServer) DeleteFileTemplate(context.Context, *FileTemplate) (*FileTemplate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteFileTemplate not implemented")
}
func (UnimplementedLMSServer) GetFileTemplate(context.Context, *FileTemplate) (*FileTemplate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFileTemplate not implemented")
}
func (UnimplementedLMSServer) CreateField(context.Context, *Field) (*Field, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateField not implemented")
}
func (UnimplementedLMSServer) ListFields(context.Context, *ListFieldsReq) (*Fields, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFields not implemented")
}
func (UnimplementedLMSServer) GetField(context.Context, *Field) (*Field, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetField not implemented")
}
func (UnimplementedLMSServer) UpdateField(context.Context, *UpdateFieldReq) (*Field, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateField not implemented")
}
func (UnimplementedLMSServer) DeleteField(context.Context, *Field) (*Field, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteField not implemented")
}
func (UnimplementedLMSServer) ListAvailableFieldsByElementId(context.Context, *ListAvailableFieldsByElementIdReq) (*ProcessFields, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAvailableFieldsByElementId not implemented")
}
func (UnimplementedLMSServer) ListFieldsForElement(context.Context, *ListFieldsForElementReq) (*ListFieldsForElementRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFieldsForElement not implemented")
}
func (UnimplementedLMSServer) ListAutocompleteFields(context.Context, *ListAutocompleteFieldsReq) (*ListAutocompleteFieldsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAutocompleteFields not implemented")
}
func (UnimplementedLMSServer) ListCampaignLinks(context.Context, *emptypb.Empty) (*ListCampaignLinksRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCampaignLinks not implemented")
}
func (UnimplementedLMSServer) PeekList(context.Context, *PeekListReq) (*PeekListRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PeekList not implemented")
}
func (UnimplementedLMSServer) GetHistory(context.Context, *GetHistoryReq) (*GetHistoryRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHistory not implemented")
}
func (UnimplementedLMSServer) CreateElement(context.Context, *Element) (*Element, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateElement not implemented")
}
func (UnimplementedLMSServer) ListElements(*ListElementsReq, LMS_ListElementsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListElements not implemented")
}
func (UnimplementedLMSServer) GetElement(context.Context, *ElementPK) (*Element, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetElement not implemented")
}
func (UnimplementedLMSServer) UpdateElement(context.Context, *Element) (*Element, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateElement not implemented")
}
func (UnimplementedLMSServer) DeleteElement(context.Context, *Element) (*Element, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteElement not implemented")
}
func (UnimplementedLMSServer) CopyPipelineUpstream(*Element, LMS_CopyPipelineUpstreamServer) error {
	return status.Errorf(codes.Unimplemented, "method CopyPipelineUpstream not implemented")
}
func (UnimplementedLMSServer) CopyPipelineDownstream(*Element, LMS_CopyPipelineDownstreamServer) error {
	return status.Errorf(codes.Unimplemented, "method CopyPipelineDownstream not implemented")
}
func (UnimplementedLMSServer) ProcessElement(context.Context, *ProcessElementReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessElement not implemented")
}
func (UnimplementedLMSServer) ProcessList(context.Context, *ProcessListRequest) (*ProcessListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ProcessList not implemented")
}
func (UnimplementedLMSServer) StreamList(LMS_StreamListServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamList not implemented")
}
func (UnimplementedLMSServer) GetAvailableFields(context.Context, *emptypb.Empty) (*ProcessFields, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAvailableFields not implemented")
}
func (UnimplementedLMSServer) ListNewEvents(context.Context, *emptypb.Empty) (*Events, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNewEvents not implemented")
}
func (UnimplementedLMSServer) ViewQueue(context.Context, *ViewQueueReq) (*Events, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ViewQueue not implemented")
}
func (UnimplementedLMSServer) Autocomplete(context.Context, *ParseReq) (*ParseRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Autocomplete not implemented")
}
func (UnimplementedLMSServer) GetComplianceScrubLists(context.Context, *GetComplianceScrubListsReq) (*GetComplianceScrubListsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetComplianceScrubLists not implemented")
}
func (UnimplementedLMSServer) FindFieldUsages(context.Context, *FindFieldUsagesReq) (*FindFieldUsagesRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindFieldUsages not implemented")
}
func (UnimplementedLMSServer) FindInvalidElements(context.Context, *FindInvalidElementsReq) (*FindInvalidElementsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindInvalidElements not implemented")
}
func (UnimplementedLMSServer) CreateCollection(context.Context, *CollectionMetadata) (*CollectionMetadata, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCollection not implemented")
}
func (UnimplementedLMSServer) GetCollection(context.Context, *GetCollectionReq) (*CollectionMetadata, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCollection not implemented")
}
func (UnimplementedLMSServer) UpdateCollection(context.Context, *CollectionMetadata) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCollection not implemented")
}
func (UnimplementedLMSServer) DeleteCollection(context.Context, *DeleteCollectionReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCollection not implemented")
}
func (UnimplementedLMSServer) ListCollections(context.Context, *ListCollectionsReq) (*ListCollectionsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCollections not implemented")
}
func (UnimplementedLMSServer) ResetCollection(context.Context, *ResetCollectionReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResetCollection not implemented")
}
func (UnimplementedLMSServer) AddCollectionEntry(context.Context, *CollectionEntry) (*CollectionEntry, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddCollectionEntry not implemented")
}
func (UnimplementedLMSServer) DeleteCollectionEntry(context.Context, *DeleteCollectionEntryReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCollectionEntry not implemented")
}
func (UnimplementedLMSServer) UpdateCollectionEntry(context.Context, *CollectionEntry) (*CollectionEntry, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCollectionEntry not implemented")
}
func (UnimplementedLMSServer) StreamCollection(*StreamCollectionReq, LMS_StreamCollectionServer) error {
	return status.Errorf(codes.Unimplemented, "method StreamCollection not implemented")
}
func (UnimplementedLMSServer) SearchCollectionsPaginated(context.Context, *SearchCollectionsPaginatedReq) (*PaginatedSearchRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchCollectionsPaginated not implemented")
}
func (UnimplementedLMSServer) GetCollectionEntries(context.Context, *GetCollectionEntriesReq) (*GetCollectionEntriesRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCollectionEntries not implemented")
}
func (UnimplementedLMSServer) CreateCjsSearchDefinition(context.Context, *CjsSearchDefinition) (*CjsSearchDefinition, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCjsSearchDefinition not implemented")
}
func (UnimplementedLMSServer) GetCjsSearchDefinition(context.Context, *GetCjsSearchDefinitionReq) (*CjsSearchDefinition, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCjsSearchDefinition not implemented")
}
func (UnimplementedLMSServer) UpdateCjsSearchDefinition(context.Context, *CjsSearchDefinition) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCjsSearchDefinition not implemented")
}
func (UnimplementedLMSServer) DeleteCjsSearchDefinition(context.Context, *DeleteCjsSearchDefinitionReq) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteCjsSearchDefinition not implemented")
}
func (UnimplementedLMSServer) ListCjsSearchDefinitions(context.Context, *ListCjsSearchDefinitionsReq) (*ListCjsSearchDefinitionsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListCjsSearchDefinitions not implemented")
}
func (UnimplementedLMSServer) ExecuteCjsSearchDefinition(context.Context, *ExecuteCjsSearchDefinitionReq) (*ExecuteCjsSearchDefinitionRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteCjsSearchDefinition not implemented")
}
func (UnimplementedLMSServer) GetCjsSecureSearchCriteria(context.Context, *GetCjsSecureSearchCriteriaReq) (*CjsSecureSearchCriteria, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetCjsSecureSearchCriteria not implemented")
}
func (UnimplementedLMSServer) CreateCjsSecureSearchCriteria(context.Context, *CjsSecureSearchCriteria) (*CjsSecureSearchCriteria, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCjsSecureSearchCriteria not implemented")
}
func (UnimplementedLMSServer) UpdateCjsSecureSearchCriteria(context.Context, *CjsSecureSearchCriteria) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateCjsSecureSearchCriteria not implemented")
}
func (UnimplementedLMSServer) SampleEndpoint(context.Context, *SampleRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SampleEndpoint not implemented")
}
func (UnimplementedLMSServer) GetAvailableEHRFields(context.Context, *EHREntityType) (*Fields, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAvailableEHRFields not implemented")
}
func (UnimplementedLMSServer) GetQueuedEventsStatusByElementId(context.Context, *ElementPK) (*Events, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQueuedEventsStatusByElementId not implemented")
}
func (UnimplementedLMSServer) ListPools(context.Context, *ListPoolsRequest) (*ListPoolsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPools not implemented")
}
func (UnimplementedLMSServer) mustEmbedUnimplementedLMSServer() {}

// UnsafeLMSServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LMSServer will
// result in compilation errors.
type UnsafeLMSServer interface {
	mustEmbedUnimplementedLMSServer()
}

func RegisterLMSServer(s grpc.ServiceRegistrar, srv LMSServer) {
	s.RegisterService(&LMS_ServiceDesc, srv)
}

func _LMS_GetPublicKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPublicKeyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).GetPublicKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_GetPublicKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).GetPublicKey(ctx, req.(*GetPublicKeyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_CreateFileTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileTemplate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).CreateFileTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_CreateFileTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).CreateFileTemplate(ctx, req.(*FileTemplate))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_ListFileTemplates_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetFileTemplatesReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LMSServer).ListFileTemplates(m, &lMSListFileTemplatesServer{ServerStream: stream})
}

type LMS_ListFileTemplatesServer interface {
	Send(*FileTemplate) error
	grpc.ServerStream
}

type lMSListFileTemplatesServer struct {
	grpc.ServerStream
}

func (x *lMSListFileTemplatesServer) Send(m *FileTemplate) error {
	return x.ServerStream.SendMsg(m)
}

func _LMS_UpdateFileTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileTemplate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).UpdateFileTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_UpdateFileTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).UpdateFileTemplate(ctx, req.(*FileTemplate))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_DeleteFileTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileTemplate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).DeleteFileTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_DeleteFileTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).DeleteFileTemplate(ctx, req.(*FileTemplate))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_GetFileTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FileTemplate)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).GetFileTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_GetFileTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).GetFileTemplate(ctx, req.(*FileTemplate))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_CreateField_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Field)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).CreateField(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_CreateField_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).CreateField(ctx, req.(*Field))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_ListFields_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFieldsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).ListFields(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_ListFields_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).ListFields(ctx, req.(*ListFieldsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_GetField_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Field)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).GetField(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_GetField_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).GetField(ctx, req.(*Field))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_UpdateField_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateFieldReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).UpdateField(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_UpdateField_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).UpdateField(ctx, req.(*UpdateFieldReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_DeleteField_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Field)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).DeleteField(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_DeleteField_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).DeleteField(ctx, req.(*Field))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_ListAvailableFieldsByElementId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAvailableFieldsByElementIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).ListAvailableFieldsByElementId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_ListAvailableFieldsByElementId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).ListAvailableFieldsByElementId(ctx, req.(*ListAvailableFieldsByElementIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_ListFieldsForElement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFieldsForElementReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).ListFieldsForElement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_ListFieldsForElement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).ListFieldsForElement(ctx, req.(*ListFieldsForElementReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_ListAutocompleteFields_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAutocompleteFieldsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).ListAutocompleteFields(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_ListAutocompleteFields_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).ListAutocompleteFields(ctx, req.(*ListAutocompleteFieldsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_ListCampaignLinks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).ListCampaignLinks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_ListCampaignLinks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).ListCampaignLinks(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_PeekList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PeekListReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).PeekList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_PeekList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).PeekList(ctx, req.(*PeekListReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_GetHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHistoryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).GetHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_GetHistory_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).GetHistory(ctx, req.(*GetHistoryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_CreateElement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Element)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).CreateElement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_CreateElement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).CreateElement(ctx, req.(*Element))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_ListElements_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListElementsReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LMSServer).ListElements(m, &lMSListElementsServer{ServerStream: stream})
}

type LMS_ListElementsServer interface {
	Send(*Element) error
	grpc.ServerStream
}

type lMSListElementsServer struct {
	grpc.ServerStream
}

func (x *lMSListElementsServer) Send(m *Element) error {
	return x.ServerStream.SendMsg(m)
}

func _LMS_GetElement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementPK)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).GetElement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_GetElement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).GetElement(ctx, req.(*ElementPK))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_UpdateElement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Element)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).UpdateElement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_UpdateElement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).UpdateElement(ctx, req.(*Element))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_DeleteElement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Element)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).DeleteElement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_DeleteElement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).DeleteElement(ctx, req.(*Element))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_CopyPipelineUpstream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Element)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LMSServer).CopyPipelineUpstream(m, &lMSCopyPipelineUpstreamServer{ServerStream: stream})
}

type LMS_CopyPipelineUpstreamServer interface {
	Send(*Element) error
	grpc.ServerStream
}

type lMSCopyPipelineUpstreamServer struct {
	grpc.ServerStream
}

func (x *lMSCopyPipelineUpstreamServer) Send(m *Element) error {
	return x.ServerStream.SendMsg(m)
}

func _LMS_CopyPipelineDownstream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Element)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LMSServer).CopyPipelineDownstream(m, &lMSCopyPipelineDownstreamServer{ServerStream: stream})
}

type LMS_CopyPipelineDownstreamServer interface {
	Send(*Element) error
	grpc.ServerStream
}

type lMSCopyPipelineDownstreamServer struct {
	grpc.ServerStream
}

func (x *lMSCopyPipelineDownstreamServer) Send(m *Element) error {
	return x.ServerStream.SendMsg(m)
}

func _LMS_ProcessElement_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessElementReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).ProcessElement(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_ProcessElement_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).ProcessElement(ctx, req.(*ProcessElementReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_ProcessList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProcessListRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).ProcessList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_ProcessList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).ProcessList(ctx, req.(*ProcessListRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_StreamList_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(LMSServer).StreamList(&lMSStreamListServer{ServerStream: stream})
}

type LMS_StreamListServer interface {
	SendAndClose(*StreamListResponse) error
	Recv() (*StreamListRequest, error)
	grpc.ServerStream
}

type lMSStreamListServer struct {
	grpc.ServerStream
}

func (x *lMSStreamListServer) SendAndClose(m *StreamListResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *lMSStreamListServer) Recv() (*StreamListRequest, error) {
	m := new(StreamListRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _LMS_GetAvailableFields_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).GetAvailableFields(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_GetAvailableFields_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).GetAvailableFields(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_ListNewEvents_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).ListNewEvents(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_ListNewEvents_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).ListNewEvents(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_ViewQueue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ViewQueueReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).ViewQueue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_ViewQueue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).ViewQueue(ctx, req.(*ViewQueueReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_Autocomplete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParseReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).Autocomplete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_Autocomplete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).Autocomplete(ctx, req.(*ParseReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_GetComplianceScrubLists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetComplianceScrubListsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).GetComplianceScrubLists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_GetComplianceScrubLists_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).GetComplianceScrubLists(ctx, req.(*GetComplianceScrubListsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_FindFieldUsages_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindFieldUsagesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).FindFieldUsages(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_FindFieldUsages_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).FindFieldUsages(ctx, req.(*FindFieldUsagesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_FindInvalidElements_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FindInvalidElementsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).FindInvalidElements(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_FindInvalidElements_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).FindInvalidElements(ctx, req.(*FindInvalidElementsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_CreateCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectionMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).CreateCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_CreateCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).CreateCollection(ctx, req.(*CollectionMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_GetCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCollectionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).GetCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_GetCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).GetCollection(ctx, req.(*GetCollectionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_UpdateCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectionMetadata)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).UpdateCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_UpdateCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).UpdateCollection(ctx, req.(*CollectionMetadata))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_DeleteCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCollectionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).DeleteCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_DeleteCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).DeleteCollection(ctx, req.(*DeleteCollectionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_ListCollections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCollectionsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).ListCollections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_ListCollections_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).ListCollections(ctx, req.(*ListCollectionsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_ResetCollection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetCollectionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).ResetCollection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_ResetCollection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).ResetCollection(ctx, req.(*ResetCollectionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_AddCollectionEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectionEntry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).AddCollectionEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_AddCollectionEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).AddCollectionEntry(ctx, req.(*CollectionEntry))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_DeleteCollectionEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCollectionEntryReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).DeleteCollectionEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_DeleteCollectionEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).DeleteCollectionEntry(ctx, req.(*DeleteCollectionEntryReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_UpdateCollectionEntry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CollectionEntry)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).UpdateCollectionEntry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_UpdateCollectionEntry_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).UpdateCollectionEntry(ctx, req.(*CollectionEntry))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_StreamCollection_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StreamCollectionReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(LMSServer).StreamCollection(m, &lMSStreamCollectionServer{ServerStream: stream})
}

type LMS_StreamCollectionServer interface {
	Send(*CollectionEntry) error
	grpc.ServerStream
}

type lMSStreamCollectionServer struct {
	grpc.ServerStream
}

func (x *lMSStreamCollectionServer) Send(m *CollectionEntry) error {
	return x.ServerStream.SendMsg(m)
}

func _LMS_SearchCollectionsPaginated_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchCollectionsPaginatedReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).SearchCollectionsPaginated(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_SearchCollectionsPaginated_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).SearchCollectionsPaginated(ctx, req.(*SearchCollectionsPaginatedReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_GetCollectionEntries_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCollectionEntriesReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).GetCollectionEntries(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_GetCollectionEntries_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).GetCollectionEntries(ctx, req.(*GetCollectionEntriesReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_CreateCjsSearchDefinition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CjsSearchDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).CreateCjsSearchDefinition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_CreateCjsSearchDefinition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).CreateCjsSearchDefinition(ctx, req.(*CjsSearchDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_GetCjsSearchDefinition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCjsSearchDefinitionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).GetCjsSearchDefinition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_GetCjsSearchDefinition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).GetCjsSearchDefinition(ctx, req.(*GetCjsSearchDefinitionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_UpdateCjsSearchDefinition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CjsSearchDefinition)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).UpdateCjsSearchDefinition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_UpdateCjsSearchDefinition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).UpdateCjsSearchDefinition(ctx, req.(*CjsSearchDefinition))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_DeleteCjsSearchDefinition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCjsSearchDefinitionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).DeleteCjsSearchDefinition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_DeleteCjsSearchDefinition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).DeleteCjsSearchDefinition(ctx, req.(*DeleteCjsSearchDefinitionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_ListCjsSearchDefinitions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCjsSearchDefinitionsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).ListCjsSearchDefinitions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_ListCjsSearchDefinitions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).ListCjsSearchDefinitions(ctx, req.(*ListCjsSearchDefinitionsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_ExecuteCjsSearchDefinition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteCjsSearchDefinitionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).ExecuteCjsSearchDefinition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_ExecuteCjsSearchDefinition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).ExecuteCjsSearchDefinition(ctx, req.(*ExecuteCjsSearchDefinitionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_GetCjsSecureSearchCriteria_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCjsSecureSearchCriteriaReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).GetCjsSecureSearchCriteria(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_GetCjsSecureSearchCriteria_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).GetCjsSecureSearchCriteria(ctx, req.(*GetCjsSecureSearchCriteriaReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_CreateCjsSecureSearchCriteria_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CjsSecureSearchCriteria)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).CreateCjsSecureSearchCriteria(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_CreateCjsSecureSearchCriteria_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).CreateCjsSecureSearchCriteria(ctx, req.(*CjsSecureSearchCriteria))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_UpdateCjsSecureSearchCriteria_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CjsSecureSearchCriteria)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).UpdateCjsSecureSearchCriteria(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_UpdateCjsSecureSearchCriteria_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).UpdateCjsSecureSearchCriteria(ctx, req.(*CjsSecureSearchCriteria))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_SampleEndpoint_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SampleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).SampleEndpoint(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_SampleEndpoint_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).SampleEndpoint(ctx, req.(*SampleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_GetAvailableEHRFields_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EHREntityType)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).GetAvailableEHRFields(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_GetAvailableEHRFields_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).GetAvailableEHRFields(ctx, req.(*EHREntityType))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_GetQueuedEventsStatusByElementId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ElementPK)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).GetQueuedEventsStatusByElementId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_GetQueuedEventsStatusByElementId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).GetQueuedEventsStatusByElementId(ctx, req.(*ElementPK))
	}
	return interceptor(ctx, in, info, handler)
}

func _LMS_ListPools_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPoolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LMSServer).ListPools(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LMS_ListPools_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LMSServer).ListPools(ctx, req.(*ListPoolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LMS_ServiceDesc is the grpc.ServiceDesc for LMS service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LMS_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.v0alpha.LMS",
	HandlerType: (*LMSServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPublicKey",
			Handler:    _LMS_GetPublicKey_Handler,
		},
		{
			MethodName: "CreateFileTemplate",
			Handler:    _LMS_CreateFileTemplate_Handler,
		},
		{
			MethodName: "UpdateFileTemplate",
			Handler:    _LMS_UpdateFileTemplate_Handler,
		},
		{
			MethodName: "DeleteFileTemplate",
			Handler:    _LMS_DeleteFileTemplate_Handler,
		},
		{
			MethodName: "GetFileTemplate",
			Handler:    _LMS_GetFileTemplate_Handler,
		},
		{
			MethodName: "CreateField",
			Handler:    _LMS_CreateField_Handler,
		},
		{
			MethodName: "ListFields",
			Handler:    _LMS_ListFields_Handler,
		},
		{
			MethodName: "GetField",
			Handler:    _LMS_GetField_Handler,
		},
		{
			MethodName: "UpdateField",
			Handler:    _LMS_UpdateField_Handler,
		},
		{
			MethodName: "DeleteField",
			Handler:    _LMS_DeleteField_Handler,
		},
		{
			MethodName: "ListAvailableFieldsByElementId",
			Handler:    _LMS_ListAvailableFieldsByElementId_Handler,
		},
		{
			MethodName: "ListFieldsForElement",
			Handler:    _LMS_ListFieldsForElement_Handler,
		},
		{
			MethodName: "ListAutocompleteFields",
			Handler:    _LMS_ListAutocompleteFields_Handler,
		},
		{
			MethodName: "ListCampaignLinks",
			Handler:    _LMS_ListCampaignLinks_Handler,
		},
		{
			MethodName: "PeekList",
			Handler:    _LMS_PeekList_Handler,
		},
		{
			MethodName: "GetHistory",
			Handler:    _LMS_GetHistory_Handler,
		},
		{
			MethodName: "CreateElement",
			Handler:    _LMS_CreateElement_Handler,
		},
		{
			MethodName: "GetElement",
			Handler:    _LMS_GetElement_Handler,
		},
		{
			MethodName: "UpdateElement",
			Handler:    _LMS_UpdateElement_Handler,
		},
		{
			MethodName: "DeleteElement",
			Handler:    _LMS_DeleteElement_Handler,
		},
		{
			MethodName: "ProcessElement",
			Handler:    _LMS_ProcessElement_Handler,
		},
		{
			MethodName: "ProcessList",
			Handler:    _LMS_ProcessList_Handler,
		},
		{
			MethodName: "GetAvailableFields",
			Handler:    _LMS_GetAvailableFields_Handler,
		},
		{
			MethodName: "ListNewEvents",
			Handler:    _LMS_ListNewEvents_Handler,
		},
		{
			MethodName: "ViewQueue",
			Handler:    _LMS_ViewQueue_Handler,
		},
		{
			MethodName: "Autocomplete",
			Handler:    _LMS_Autocomplete_Handler,
		},
		{
			MethodName: "GetComplianceScrubLists",
			Handler:    _LMS_GetComplianceScrubLists_Handler,
		},
		{
			MethodName: "FindFieldUsages",
			Handler:    _LMS_FindFieldUsages_Handler,
		},
		{
			MethodName: "FindInvalidElements",
			Handler:    _LMS_FindInvalidElements_Handler,
		},
		{
			MethodName: "CreateCollection",
			Handler:    _LMS_CreateCollection_Handler,
		},
		{
			MethodName: "GetCollection",
			Handler:    _LMS_GetCollection_Handler,
		},
		{
			MethodName: "UpdateCollection",
			Handler:    _LMS_UpdateCollection_Handler,
		},
		{
			MethodName: "DeleteCollection",
			Handler:    _LMS_DeleteCollection_Handler,
		},
		{
			MethodName: "ListCollections",
			Handler:    _LMS_ListCollections_Handler,
		},
		{
			MethodName: "ResetCollection",
			Handler:    _LMS_ResetCollection_Handler,
		},
		{
			MethodName: "AddCollectionEntry",
			Handler:    _LMS_AddCollectionEntry_Handler,
		},
		{
			MethodName: "DeleteCollectionEntry",
			Handler:    _LMS_DeleteCollectionEntry_Handler,
		},
		{
			MethodName: "UpdateCollectionEntry",
			Handler:    _LMS_UpdateCollectionEntry_Handler,
		},
		{
			MethodName: "SearchCollectionsPaginated",
			Handler:    _LMS_SearchCollectionsPaginated_Handler,
		},
		{
			MethodName: "GetCollectionEntries",
			Handler:    _LMS_GetCollectionEntries_Handler,
		},
		{
			MethodName: "CreateCjsSearchDefinition",
			Handler:    _LMS_CreateCjsSearchDefinition_Handler,
		},
		{
			MethodName: "GetCjsSearchDefinition",
			Handler:    _LMS_GetCjsSearchDefinition_Handler,
		},
		{
			MethodName: "UpdateCjsSearchDefinition",
			Handler:    _LMS_UpdateCjsSearchDefinition_Handler,
		},
		{
			MethodName: "DeleteCjsSearchDefinition",
			Handler:    _LMS_DeleteCjsSearchDefinition_Handler,
		},
		{
			MethodName: "ListCjsSearchDefinitions",
			Handler:    _LMS_ListCjsSearchDefinitions_Handler,
		},
		{
			MethodName: "ExecuteCjsSearchDefinition",
			Handler:    _LMS_ExecuteCjsSearchDefinition_Handler,
		},
		{
			MethodName: "GetCjsSecureSearchCriteria",
			Handler:    _LMS_GetCjsSecureSearchCriteria_Handler,
		},
		{
			MethodName: "CreateCjsSecureSearchCriteria",
			Handler:    _LMS_CreateCjsSecureSearchCriteria_Handler,
		},
		{
			MethodName: "UpdateCjsSecureSearchCriteria",
			Handler:    _LMS_UpdateCjsSecureSearchCriteria_Handler,
		},
		{
			MethodName: "SampleEndpoint",
			Handler:    _LMS_SampleEndpoint_Handler,
		},
		{
			MethodName: "GetAvailableEHRFields",
			Handler:    _LMS_GetAvailableEHRFields_Handler,
		},
		{
			MethodName: "GetQueuedEventsStatusByElementId",
			Handler:    _LMS_GetQueuedEventsStatusByElementId_Handler,
		},
		{
			MethodName: "ListPools",
			Handler:    _LMS_ListPools_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListFileTemplates",
			Handler:       _LMS_ListFileTemplates_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "ListElements",
			Handler:       _LMS_ListElements_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CopyPipelineUpstream",
			Handler:       _LMS_CopyPipelineUpstream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "CopyPipelineDownstream",
			Handler:       _LMS_CopyPipelineDownstream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "StreamList",
			Handler:       _LMS_StreamList_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "StreamCollection",
			Handler:       _LMS_StreamCollection_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/v0alpha/lms.proto",
}
