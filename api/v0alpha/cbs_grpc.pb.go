// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             (unknown)
// source: api/v0alpha/cbs.proto

package v0alpha

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.62.0 or later.
const _ = grpc.SupportPackageIsVersion8

const (
	CBS_CreateServiceId_FullMethodName                           = "/api.v0alpha.CBS/CreateServiceId"
	CBS_CreateCallbackWithDetails_FullMethodName                 = "/api.v0alpha.CBS/CreateCallbackWithDetails"
	CBS_UpdateScheduledCallbackToReady_FullMethodName            = "/api.v0alpha.CBS/UpdateScheduledCallbackToReady"
	CBS_UpdateScheduledCallbackToCanceled_FullMethodName         = "/api.v0alpha.CBS/UpdateScheduledCallbackToCanceled"
	CBS_GetNextScheduledCallbackWithDetails_FullMethodName       = "/api.v0alpha.CBS/GetNextScheduledCallbackWithDetails"
	CBS_UpdateScheduledCallbackToClosed_FullMethodName           = "/api.v0alpha.CBS/UpdateScheduledCallbackToClosed"
	CBS_UpdateScheduledCallback_FullMethodName                   = "/api.v0alpha.CBS/UpdateScheduledCallback"
	CBS_GetScheduledCallbackWithDetails_FullMethodName           = "/api.v0alpha.CBS/GetScheduledCallbackWithDetails"
	CBS_ListScheduledCallbacksWithDetails_FullMethodName         = "/api.v0alpha.CBS/ListScheduledCallbacksWithDetails"
	CBS_ListScheduledCallbacksWithDetailsBySkills_FullMethodName = "/api.v0alpha.CBS/ListScheduledCallbacksWithDetailsBySkills"
)

// CBSClient is the client API for CBS service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CBSClient interface {
	CreateServiceId(ctx context.Context, in *CreateServiceIdReq, opts ...grpc.CallOption) (*CreateServiceIdRes, error)
	CreateCallbackWithDetails(ctx context.Context, in *CreateCallbackWithDetailsReq, opts ...grpc.CallOption) (*CreateCallbackWithDetailsRes, error)
	UpdateScheduledCallbackToReady(ctx context.Context, in *UpdateScheduledCallbackToReadyReq, opts ...grpc.CallOption) (*UpdateScheduledCallbackToReadyRes, error)
	UpdateScheduledCallbackToCanceled(ctx context.Context, in *UpdateScheduledCallbackToCanceledReq, opts ...grpc.CallOption) (*UpdateScheduledCallbackToCanceledRes, error)
	// Skills that are a matching subset of the ones provided in the request.
	// If a callback is found the status of the callback is set to OPEN.
	// Required permissions:
	//
	//	NONE
	//
	// Errors:
	//   - grpc.Invalid: the service_id provided in the request is invalid.
	//   - grpc.NotFound: no matching service_id is found.
	//     callback is not found after updating the status of it to OPEN (shouldn't happen).
	GetNextScheduledCallbackWithDetails(ctx context.Context, in *GetNextScheduledCallbackWithDetailsReq, opts ...grpc.CallOption) (*GetNextScheduledCallbackWithDetailsRes, error)
	UpdateScheduledCallbackToClosed(ctx context.Context, in *UpdateScheduledCallbackToClosedReq, opts ...grpc.CallOption) (*UpdateScheduledCallbackToClosedRes, error)
	// Updates a callback with the provided info, and replaces the details with the ones provided.
	UpdateScheduledCallback(ctx context.Context, in *UpdateScheduledCallbackReq, opts ...grpc.CallOption) (*UpdateScheduledCallbackRes, error)
	// Gets a scheduled callback's info and it's details for the given scheduled_callback_id.
	GetScheduledCallbackWithDetails(ctx context.Context, in *GetScheduledCallbackWithDetailsReq, opts ...grpc.CallOption) (*GetScheduledCallbackWithDetailsRes, error)
	// Lists callbacks by phone number, caller id, or time range
	ListScheduledCallbacksWithDetails(ctx context.Context, in *ListScheduledCallbacksWithDetailsReq, opts ...grpc.CallOption) (CBS_ListScheduledCallbacksWithDetailsClient, error)
	// List callbacks by skills
	ListScheduledCallbacksWithDetailsBySkills(ctx context.Context, in *ListScheduledCallbacksWithDetailsBySkillsReq, opts ...grpc.CallOption) (*ListScheduledCallbacksWithDetailsRes, error)
}

type cBSClient struct {
	cc grpc.ClientConnInterface
}

func NewCBSClient(cc grpc.ClientConnInterface) CBSClient {
	return &cBSClient{cc}
}

func (c *cBSClient) CreateServiceId(ctx context.Context, in *CreateServiceIdReq, opts ...grpc.CallOption) (*CreateServiceIdRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateServiceIdRes)
	err := c.cc.Invoke(ctx, CBS_CreateServiceId_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cBSClient) CreateCallbackWithDetails(ctx context.Context, in *CreateCallbackWithDetailsReq, opts ...grpc.CallOption) (*CreateCallbackWithDetailsRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateCallbackWithDetailsRes)
	err := c.cc.Invoke(ctx, CBS_CreateCallbackWithDetails_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cBSClient) UpdateScheduledCallbackToReady(ctx context.Context, in *UpdateScheduledCallbackToReadyReq, opts ...grpc.CallOption) (*UpdateScheduledCallbackToReadyRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateScheduledCallbackToReadyRes)
	err := c.cc.Invoke(ctx, CBS_UpdateScheduledCallbackToReady_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cBSClient) UpdateScheduledCallbackToCanceled(ctx context.Context, in *UpdateScheduledCallbackToCanceledReq, opts ...grpc.CallOption) (*UpdateScheduledCallbackToCanceledRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateScheduledCallbackToCanceledRes)
	err := c.cc.Invoke(ctx, CBS_UpdateScheduledCallbackToCanceled_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cBSClient) GetNextScheduledCallbackWithDetails(ctx context.Context, in *GetNextScheduledCallbackWithDetailsReq, opts ...grpc.CallOption) (*GetNextScheduledCallbackWithDetailsRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetNextScheduledCallbackWithDetailsRes)
	err := c.cc.Invoke(ctx, CBS_GetNextScheduledCallbackWithDetails_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cBSClient) UpdateScheduledCallbackToClosed(ctx context.Context, in *UpdateScheduledCallbackToClosedReq, opts ...grpc.CallOption) (*UpdateScheduledCallbackToClosedRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateScheduledCallbackToClosedRes)
	err := c.cc.Invoke(ctx, CBS_UpdateScheduledCallbackToClosed_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cBSClient) UpdateScheduledCallback(ctx context.Context, in *UpdateScheduledCallbackReq, opts ...grpc.CallOption) (*UpdateScheduledCallbackRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateScheduledCallbackRes)
	err := c.cc.Invoke(ctx, CBS_UpdateScheduledCallback_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cBSClient) GetScheduledCallbackWithDetails(ctx context.Context, in *GetScheduledCallbackWithDetailsReq, opts ...grpc.CallOption) (*GetScheduledCallbackWithDetailsRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetScheduledCallbackWithDetailsRes)
	err := c.cc.Invoke(ctx, CBS_GetScheduledCallbackWithDetails_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *cBSClient) ListScheduledCallbacksWithDetails(ctx context.Context, in *ListScheduledCallbacksWithDetailsReq, opts ...grpc.CallOption) (CBS_ListScheduledCallbacksWithDetailsClient, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &CBS_ServiceDesc.Streams[0], CBS_ListScheduledCallbacksWithDetails_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &cBSListScheduledCallbacksWithDetailsClient{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CBS_ListScheduledCallbacksWithDetailsClient interface {
	Recv() (*ListScheduledCallbacksWithDetailsRes, error)
	grpc.ClientStream
}

type cBSListScheduledCallbacksWithDetailsClient struct {
	grpc.ClientStream
}

func (x *cBSListScheduledCallbacksWithDetailsClient) Recv() (*ListScheduledCallbacksWithDetailsRes, error) {
	m := new(ListScheduledCallbacksWithDetailsRes)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *cBSClient) ListScheduledCallbacksWithDetailsBySkills(ctx context.Context, in *ListScheduledCallbacksWithDetailsBySkillsReq, opts ...grpc.CallOption) (*ListScheduledCallbacksWithDetailsRes, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListScheduledCallbacksWithDetailsRes)
	err := c.cc.Invoke(ctx, CBS_ListScheduledCallbacksWithDetailsBySkills_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CBSServer is the server API for CBS service.
// All implementations must embed UnimplementedCBSServer
// for forward compatibility.
type CBSServer interface {
	CreateServiceId(context.Context, *CreateServiceIdReq) (*CreateServiceIdRes, error)
	CreateCallbackWithDetails(context.Context, *CreateCallbackWithDetailsReq) (*CreateCallbackWithDetailsRes, error)
	UpdateScheduledCallbackToReady(context.Context, *UpdateScheduledCallbackToReadyReq) (*UpdateScheduledCallbackToReadyRes, error)
	UpdateScheduledCallbackToCanceled(context.Context, *UpdateScheduledCallbackToCanceledReq) (*UpdateScheduledCallbackToCanceledRes, error)
	// Skills that are a matching subset of the ones provided in the request.
	// If a callback is found the status of the callback is set to OPEN.
	// Required permissions:
	//
	//	NONE
	//
	// Errors:
	//   - grpc.Invalid: the service_id provided in the request is invalid.
	//   - grpc.NotFound: no matching service_id is found.
	//     callback is not found after updating the status of it to OPEN (shouldn't happen).
	GetNextScheduledCallbackWithDetails(context.Context, *GetNextScheduledCallbackWithDetailsReq) (*GetNextScheduledCallbackWithDetailsRes, error)
	UpdateScheduledCallbackToClosed(context.Context, *UpdateScheduledCallbackToClosedReq) (*UpdateScheduledCallbackToClosedRes, error)
	// Updates a callback with the provided info, and replaces the details with the ones provided.
	UpdateScheduledCallback(context.Context, *UpdateScheduledCallbackReq) (*UpdateScheduledCallbackRes, error)
	// Gets a scheduled callback's info and it's details for the given scheduled_callback_id.
	GetScheduledCallbackWithDetails(context.Context, *GetScheduledCallbackWithDetailsReq) (*GetScheduledCallbackWithDetailsRes, error)
	// Lists callbacks by phone number, caller id, or time range
	ListScheduledCallbacksWithDetails(*ListScheduledCallbacksWithDetailsReq, CBS_ListScheduledCallbacksWithDetailsServer) error
	// List callbacks by skills
	ListScheduledCallbacksWithDetailsBySkills(context.Context, *ListScheduledCallbacksWithDetailsBySkillsReq) (*ListScheduledCallbacksWithDetailsRes, error)
	mustEmbedUnimplementedCBSServer()
}

// UnimplementedCBSServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedCBSServer struct{}

func (UnimplementedCBSServer) CreateServiceId(context.Context, *CreateServiceIdReq) (*CreateServiceIdRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateServiceId not implemented")
}
func (UnimplementedCBSServer) CreateCallbackWithDetails(context.Context, *CreateCallbackWithDetailsReq) (*CreateCallbackWithDetailsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateCallbackWithDetails not implemented")
}
func (UnimplementedCBSServer) UpdateScheduledCallbackToReady(context.Context, *UpdateScheduledCallbackToReadyReq) (*UpdateScheduledCallbackToReadyRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateScheduledCallbackToReady not implemented")
}
func (UnimplementedCBSServer) UpdateScheduledCallbackToCanceled(context.Context, *UpdateScheduledCallbackToCanceledReq) (*UpdateScheduledCallbackToCanceledRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateScheduledCallbackToCanceled not implemented")
}
func (UnimplementedCBSServer) GetNextScheduledCallbackWithDetails(context.Context, *GetNextScheduledCallbackWithDetailsReq) (*GetNextScheduledCallbackWithDetailsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNextScheduledCallbackWithDetails not implemented")
}
func (UnimplementedCBSServer) UpdateScheduledCallbackToClosed(context.Context, *UpdateScheduledCallbackToClosedReq) (*UpdateScheduledCallbackToClosedRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateScheduledCallbackToClosed not implemented")
}
func (UnimplementedCBSServer) UpdateScheduledCallback(context.Context, *UpdateScheduledCallbackReq) (*UpdateScheduledCallbackRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateScheduledCallback not implemented")
}
func (UnimplementedCBSServer) GetScheduledCallbackWithDetails(context.Context, *GetScheduledCallbackWithDetailsReq) (*GetScheduledCallbackWithDetailsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetScheduledCallbackWithDetails not implemented")
}
func (UnimplementedCBSServer) ListScheduledCallbacksWithDetails(*ListScheduledCallbacksWithDetailsReq, CBS_ListScheduledCallbacksWithDetailsServer) error {
	return status.Errorf(codes.Unimplemented, "method ListScheduledCallbacksWithDetails not implemented")
}
func (UnimplementedCBSServer) ListScheduledCallbacksWithDetailsBySkills(context.Context, *ListScheduledCallbacksWithDetailsBySkillsReq) (*ListScheduledCallbacksWithDetailsRes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListScheduledCallbacksWithDetailsBySkills not implemented")
}
func (UnimplementedCBSServer) mustEmbedUnimplementedCBSServer() {}
func (UnimplementedCBSServer) testEmbeddedByValue()             {}

// UnsafeCBSServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CBSServer will
// result in compilation errors.
type UnsafeCBSServer interface {
	mustEmbedUnimplementedCBSServer()
}

func RegisterCBSServer(s grpc.ServiceRegistrar, srv CBSServer) {
	// If the following call pancis, it indicates UnimplementedCBSServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&CBS_ServiceDesc, srv)
}

func _CBS_CreateServiceId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateServiceIdReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CBSServer).CreateServiceId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CBS_CreateServiceId_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CBSServer).CreateServiceId(ctx, req.(*CreateServiceIdReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CBS_CreateCallbackWithDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateCallbackWithDetailsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CBSServer).CreateCallbackWithDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CBS_CreateCallbackWithDetails_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CBSServer).CreateCallbackWithDetails(ctx, req.(*CreateCallbackWithDetailsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CBS_UpdateScheduledCallbackToReady_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateScheduledCallbackToReadyReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CBSServer).UpdateScheduledCallbackToReady(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CBS_UpdateScheduledCallbackToReady_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CBSServer).UpdateScheduledCallbackToReady(ctx, req.(*UpdateScheduledCallbackToReadyReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CBS_UpdateScheduledCallbackToCanceled_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateScheduledCallbackToCanceledReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CBSServer).UpdateScheduledCallbackToCanceled(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CBS_UpdateScheduledCallbackToCanceled_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CBSServer).UpdateScheduledCallbackToCanceled(ctx, req.(*UpdateScheduledCallbackToCanceledReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CBS_GetNextScheduledCallbackWithDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNextScheduledCallbackWithDetailsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CBSServer).GetNextScheduledCallbackWithDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CBS_GetNextScheduledCallbackWithDetails_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CBSServer).GetNextScheduledCallbackWithDetails(ctx, req.(*GetNextScheduledCallbackWithDetailsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CBS_UpdateScheduledCallbackToClosed_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateScheduledCallbackToClosedReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CBSServer).UpdateScheduledCallbackToClosed(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CBS_UpdateScheduledCallbackToClosed_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CBSServer).UpdateScheduledCallbackToClosed(ctx, req.(*UpdateScheduledCallbackToClosedReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CBS_UpdateScheduledCallback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateScheduledCallbackReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CBSServer).UpdateScheduledCallback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CBS_UpdateScheduledCallback_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CBSServer).UpdateScheduledCallback(ctx, req.(*UpdateScheduledCallbackReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CBS_GetScheduledCallbackWithDetails_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetScheduledCallbackWithDetailsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CBSServer).GetScheduledCallbackWithDetails(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CBS_GetScheduledCallbackWithDetails_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CBSServer).GetScheduledCallbackWithDetails(ctx, req.(*GetScheduledCallbackWithDetailsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _CBS_ListScheduledCallbacksWithDetails_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListScheduledCallbacksWithDetailsReq)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CBSServer).ListScheduledCallbacksWithDetails(m, &cBSListScheduledCallbacksWithDetailsServer{ServerStream: stream})
}

type CBS_ListScheduledCallbacksWithDetailsServer interface {
	Send(*ListScheduledCallbacksWithDetailsRes) error
	grpc.ServerStream
}

type cBSListScheduledCallbacksWithDetailsServer struct {
	grpc.ServerStream
}

func (x *cBSListScheduledCallbacksWithDetailsServer) Send(m *ListScheduledCallbacksWithDetailsRes) error {
	return x.ServerStream.SendMsg(m)
}

func _CBS_ListScheduledCallbacksWithDetailsBySkills_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListScheduledCallbacksWithDetailsBySkillsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CBSServer).ListScheduledCallbacksWithDetailsBySkills(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CBS_ListScheduledCallbacksWithDetailsBySkills_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CBSServer).ListScheduledCallbacksWithDetailsBySkills(ctx, req.(*ListScheduledCallbacksWithDetailsBySkillsReq))
	}
	return interceptor(ctx, in, info, handler)
}

// CBS_ServiceDesc is the grpc.ServiceDesc for CBS service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CBS_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "api.v0alpha.CBS",
	HandlerType: (*CBSServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateServiceId",
			Handler:    _CBS_CreateServiceId_Handler,
		},
		{
			MethodName: "CreateCallbackWithDetails",
			Handler:    _CBS_CreateCallbackWithDetails_Handler,
		},
		{
			MethodName: "UpdateScheduledCallbackToReady",
			Handler:    _CBS_UpdateScheduledCallbackToReady_Handler,
		},
		{
			MethodName: "UpdateScheduledCallbackToCanceled",
			Handler:    _CBS_UpdateScheduledCallbackToCanceled_Handler,
		},
		{
			MethodName: "GetNextScheduledCallbackWithDetails",
			Handler:    _CBS_GetNextScheduledCallbackWithDetails_Handler,
		},
		{
			MethodName: "UpdateScheduledCallbackToClosed",
			Handler:    _CBS_UpdateScheduledCallbackToClosed_Handler,
		},
		{
			MethodName: "UpdateScheduledCallback",
			Handler:    _CBS_UpdateScheduledCallback_Handler,
		},
		{
			MethodName: "GetScheduledCallbackWithDetails",
			Handler:    _CBS_GetScheduledCallbackWithDetails_Handler,
		},
		{
			MethodName: "ListScheduledCallbacksWithDetailsBySkills",
			Handler:    _CBS_ListScheduledCallbacksWithDetailsBySkills_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "ListScheduledCallbacksWithDetails",
			Handler:       _CBS_ListScheduledCallbacksWithDetails_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "api/v0alpha/cbs.proto",
}
